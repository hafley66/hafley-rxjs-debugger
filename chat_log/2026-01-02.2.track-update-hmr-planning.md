# Session: track-update HMR System Planning

## Goal
Design and plan the track-update mechanism for RxJS HMR - when/how to emit track-update events, handle source swapping, and support Subjects as both source and sink.

## Current State
- **Branch**: `feature/vite-instrumentation-v2`
- **Commit**: `b132640` - docs: add session logs and track-update system plan
- **Tests**: All 52 passing
- **Plan file**: `chat_log/plans/2026-01-02.track-update-system.md`

## Problem/Context
Need to determine:
1. WHEN to emit track-update (what triggers it)
2. HOW to handle source swapping in trackedObservable
3. WHAT to do with Subjects that are both subscribed to AND have `.next()` called from outside their `__$` scope

## Solution/Approach (MVP)

### Decision Tree
```
Code Change (HMR) → __$(location) re-executes
                          ↓
              Does hmr_track[location] exist?
                    /           \
                  NO            YES
                  ↓              ↓
              Normal       entity_id different?
               flow              ↓
                               YES → Update entity_id in place
                                     trackedObservable swaps source
```

### Key Decisions
| Question | Decision |
|----------|----------|
| Hash comparison? | **Defer** - always update on entity_id change, add hash optimization later |
| Complete propagation? | **Suppress during swap only** - track swapping state, forward otherwise |
| Subject bidirectional? | **Instance patching** - patch .next/.error/.complete on Subject instances in __$ |

## Tasks
- [ ] Phase 1: Modify `track-call-return` in accumulator to detect re-execution and update entity_id
- [ ] Phase 2: Add `isSwapping` flag to trackedObservable, suppress complete during swap
- [ ] Phase 3: Patch Subject instances in `__$` to forward .next/.error/.complete to current entity
- [ ] Add tests for swap scenarios

## Files to Modify
1. `src/tracking/v2/03_scan-accumulator.ts` - track-call-return handler
2. `src/tracking/v2/hmr/2_tracked-observable.ts` - silent swap during transition
3. `src/tracking/v2/hmr/0_runtime.ts` - Subject instance patching

## Key Insights

1. **arg-crawler already supports HMR**: Line 44-46 looks up `fn_ref` at call time from state$, enabling function hot-swap without re-subscription

2. **Subject bidirectional problem**: If Subject is created in module A, subscribed in B, and `.next()` called from C - HMR replaces instance but C still has old reference. Solution: patch the instance's methods to forward to current entity.

3. **Silent swap**: Don't propagate complete during source swap - would kill the outer subscription. Only suppress during the transition, forward normally otherwise.

4. **Future optimization**: Structural hash comparison to detect fn-only changes (skip track-update, just swap fn_refs). Deferred for MVP.

## Open Questions
- None currently - ready to implement

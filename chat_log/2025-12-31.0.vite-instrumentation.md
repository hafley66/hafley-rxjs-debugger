# 2025-12-31 Vite Plugin Full Instrumentation

## Goal
Auto-instrument ALL rxjs operators and creation functions at the source level, including internal rxjs calls.

## Current State
- **Branch**: `feature/vite-instrumentation-v2`
- **Observable constructor patching**: Working via regex transform in vite plugin (3 patterns: esm5, esm, ts)
- **04.operators.ts**: Updated with all ~100 operators as named exports + legacy proxy object
- **Decorators**: `decorateOperatorFun` and `decorateCreate` in 01.patch-observable.ts
- **Arg crawler**: Walks args to find/wrap functions, track observable refs, store primitives

## Problem
Current approach only intercepts app-level imports (`import { map } from 'rxjs'`). Internal rxjs code (e.g., `switchMap` calling `innerFrom`) uses relative imports that bypass our interception.

## Solution: Inline Source Transformation
Same pattern as Observable constructor - detect operator/creation files and inject decorators inline.

### Transform Targets
1. `/rxjs/src/internal/operators/*.ts` - pipeable operators
2. `/rxjs/src/internal/observable/*.ts` - creation operators (from, of, timer, etc.)
3. Also handle `/rxjs/dist/esm/` and `/rxjs/dist/esm5/` variants

### Export Pattern (from rxjs source)
```ts
// Overload signatures (no body)
export function map<T, R>(project: ...): OperatorFunction<T, R>;
export function map<T, R, A>(project: ..., thisArg: A): OperatorFunction<T, R>;

// Implementation (has body)
export function map<T, R>(project: ..., thisArg?: any): OperatorFunction<T, R> {
  return operate(...);
}
```

### Transform Strategy
Use ast-grep to:
1. Find the implementation function (the one with a body)
2. Inject decorator import
3. Wrap: `const __map__ = function map(...) {...}; export const map = __decorate__(__map__, "map");`

## Tasks

### Phase 1: Vite Config
- [ ] Exclude rxjs from pre-bundling (`optimizeDeps.exclude`)
- [ ] Alias rxjs to source TypeScript (`resolve.alias`)

### Phase 2: Transform Operators
- [ ] Detect operator files in transform hook
- [ ] Use ast-grep to find export function with body
- [ ] Inject `decorateOperatorFun` wrapper
- [ ] Handle overload signatures (keep as-is, only wrap implementation)

### Phase 3: Transform Creation Operators
- [ ] Detect creation files (`/observable/*.ts`)
- [ ] Use ast-grep to find export function
- [ ] Inject `decorateCreate` wrapper

### Phase 4: Testing
- [ ] Verify internal rxjs calls are instrumented
- [ ] Test vitest, vitest browser, dev mode all work
- [ ] Ensure no circular imports or resolution issues

## Files to Modify
- `src/vite-plugin/v2.ts` - add operator/creation transform logic
- `vite.config.ts` - add optimizeDeps.exclude, resolve.alias

## Files Reference
- `src/tracking/v2/01.patch-observable.ts` - decorators live here
- `src/tracking/v2/04.operators.ts` - named exports (may become unnecessary after inline transform)

## Key Insight
The 04.operators.ts file might become a **fallback/manual import** only. If inline transform works, app code can `import { map } from 'rxjs'` directly and get instrumented version because the source itself is decorated.

## Open Questions
1. Should we keep 04.operators.ts for lib/test manual imports?
2. ast-grep vs regex for transform? (leaning ast-grep for robustness)
3. Handle edge cases like re-exports in index files?

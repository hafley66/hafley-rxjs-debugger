# Session: HMR Double Subscription Bug Fix

## Goal
Fix double subscription and broken nested tracking bugs in the HMR tracking system for RxJS observables.

## Current State
- **Branch**: `feature/vite-instrumentation-v2`
- **Tests**: 82 passing, 3 skipped
- **Key files modified**:
  - `src/tracking/v2/hmr/0_runtime.ts` - Added TRACKED_MARKER, isRealSubject(), isTrackedWrapper()
  - `src/tracking/v2/hmr/2_tracked-observable.ts` - Cleaned debug logs
  - `src/tracking/v2/hmr/3_tracked-subject.ts` - Cleaned debug logs
  - `src/tracking/v2/hmr/5_react-query-torture.test.ts` - NEW diagnostic test suite

## Problems Fixed

### Bug 1: AnonymousSubject from .pipe() treated as real Subject
- `trigger$.pipe(switchMap(...))` returns `AnonymousSubject`
- Passed `instanceof Subject` check
- `__$` wrapped it with `trackedSubject` → bidirectional sync subscribed to source → double subscription

**Fix**: `isRealSubject()` checks `val.constructor === Subject || BehaviorSubject` to exclude lifted observables

### Bug 2: Already-tracked wrappers wrapped again
- `$("inner", () => response$)` where `response$` is already tracked
- Created NEW wrapper for `outer:inner` with no entity_id (no constructor fires)
- `trackedSubject.subscribe()` fell back to proxy → values lost

**Fix**: Added `TRACKED_MARKER` symbol. `__$` detects tracked wrappers and returns them directly.

## Key Insights

1. **AnonymousSubject** is an internal RxJS type for lifted observables from `.pipe()` - it extends Subject but shouldn't trigger bi-sync
2. **Tracked wrappers need marking** - symbol marker prevents double-wrapping when returning existing tracked observables
3. **Null checks critical** - `isRealSubject()` and `isTrackedWrapper()` must handle undefined results
4. **Track keys are GLOBAL, not module-scoped** - `hmr_track["response$"]` is shared across all modules. Two tests using same key will interfere. Tests must use unique keys per test. Real fix: track lookup should include module_id.
5. **Module cleanup is the intended fix for watcher cleanup** - `hmr-module-call-return` handles orphan detection and dangling sub cleanup. trackedSubject state$$ watchers should be tied to this lifecycle.

## Code Changes

```ts
// 0_runtime.ts
export const TRACKED_MARKER = Symbol("rxjs-debugger-tracked")

function isRealSubject(val: any): val is Subject<any> {
  if (val == null) return false
  if ((val as any)[TRACKED_MARKER]) return false
  return val.constructor === Subject || val.constructor === BehaviorSubject
}

function isTrackedWrapper(val: any): boolean {
  return val != null && !!(val as any)[TRACKED_MARKER]
}

// In __$():
if (isTrackedWrapper(result)) {
  return result  // Already tracked, don't wrap again
}

// When creating wrappers:
;(stable as any)[TRACKED_MARKER] = true
```

## Tasks
- [x] Identify double subscription root cause
- [x] Fix AnonymousSubject detection
- [x] Fix already-tracked wrapper detection
- [x] Add TRACKED_MARKER system
- [x] Create diagnostic test suite (5 tests)
- [x] Clean up debug logs
- [x] Make test track keys unique to avoid cross-test pollution
- [ ] Scope track keys to module_id in lookup (real fix for key collision)
- [ ] Tie trackedSubject state$$ watcher to module lifecycle

## Open Questions
1. **Track key scoping**: Should `hmr_track` keys include module_id prefix? e.g., `"file:///foo.ts:response$"` instead of just `"response$"`
   - Pro: Proper isolation between modules
   - Con: HMR re-execution detection relies on same key being reused
   - Answer: Module-scoped keys ARE correct. Current behavior is for HMR where same module is reloaded. Different modules should have different track keys naturally (they're different files)

2. **Watcher cleanup**: trackedSubject creates a persistent state$$ watcher. Should clean up on:
   - Option A: Module end (`hmr-module-call-return`)
   - Option B: When no subscribers remain
   - Option C: When track is orphaned
   - Current workaround: Tests use unique keys per test

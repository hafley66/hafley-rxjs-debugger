# Task: Dangling Track Detection / GC

## Problem
After HMR reload, tracks from deleted/moved code remain in store. No way to detect which tracks are orphaned.

## Solution
Add `module` field to `hmr_track` + new `hmr_module` entity to track module execution spans.

### Types
```ts
// Global - read imperatively during scan
export const currentModule$ = new BehaviorSubject<string | null>(null)

// New entity
hmr_module: {
  // id = module path "/src/foo.ts"
  updated_at?: number  // last HMR touch
}

// hmr_track additions
hmr_track: {
  module?: string      // FK to hmr_module, stamped from currentModule$
  updated_at?: number  // last time touched
}
```

### Events
```ts
| { type: "hmr-module-call"; id: string; /* vite hmr metadata */ }
| { type: "hmr-module-call-return"; id: string }
```

### Accumulator Logic
```ts
case "hmr-module-call":
  currentModule$.next(event.id)
  // upsert hmr_module, bump updated_at

case "track-call":
  entity.module = currentModule$.value  // stamp

case "hmr-module-call-return":
  // dangling = tracks where module === id && updated_at < module.updated_at
  currentModule$.next(null)
```

### Vite Plugin
Inject at module boundaries:
```ts
// start of module
__hmr_module_start("/src/foo.ts", import.meta.hot)

// end of module
__hmr_module_end("/src/foo.ts")
```

## Edge Cases
- Async import timing (defer for now)
- Module vs function execution context

## Status
Scaffolded, not implemented. Return when stable-ref work complete.

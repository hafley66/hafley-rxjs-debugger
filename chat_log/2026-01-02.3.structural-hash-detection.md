# Session: Structural Hash Detection for HMR

## Goal
Implement structural hash detection to distinguish between "structure changed" vs "fn-only changed" during HMR re-execution.

## Current State
- **Branch**: `feature/vite-instrumentation-v2`
- **Commit**: `4649160` - feat: add structural hash detection for HMR track-update
- **Tests**: All 56 passing

## What Was Done

### 1. Structural Serialization
Added `serializeValue`/`serializeArgs` helpers that serialize args into structural fingerprints:
- Functions → `"fn"`
- Observables → `"$ref[id]"`
- Primitives → literal values
- Objects → sorted key:value pairs `{count:2,delay:fn}`
- Arrays → `[val,val,val]`

### 2. Operator/Observable Naming
- `operator-fun-call`: Sets name like `"map(fn)"`, `"take(5)"`, `"repeat({count:2,delay:fn})"`
- `operator-call-return`: Chains names: `targetObs.name = sourceObs.name + "." + opFun.name`
- `factory-call-return`: Sets name like `"of(1,2,3)"`, `"from($ref[0])"`

### 3. Track Re-execution Detection
In `track-call-return`:
- Detects when `hmr_track[id]` already exists with different `entity_id`
- Compares old vs new observable names
- Sets `last_change_structural: true/false`
- Updates `entity_id`, increments `version`, pushes old to `prev_entity_ids`

### 4. Fixed Lift Suppression
- Commented out `lift` tracking suppression
- Pipe output observables now captured in `store.observable`
- Structural chaining works end-to-end

## Key Files Modified
- `src/tracking/v2/03_scan-accumulator.ts` - serialization + all handler updates
- `src/tracking/v2/01.patch-observable.ts` - disabled lift suppression
- `src/tracking/v2/01.patch-observable.test.ts` - added pipe output test
- `src/tracking/v2/hmr/0_runtime.test.ts` - added structural detection tests

## Example Output
```
First:  of(1,2,3).map(fn)
After:  of(1,2,3).map(fn).filter(fn)
→ structural: true, version: 1
```

```
First:  of(1,2,3).map(fn)  // x => x * 2
After:  of(1,2,3).map(fn)  // x => x * 3
→ structural: false, version: 1
```

## Next Steps (Phase 2 & 3 from plan)
- [ ] Phase 2: Add `isSwapping` flag to trackedObservable, suppress complete during swap
- [ ] Phase 3: Patch Subject instances in `__$` to forward .next/.error/.complete to current entity

## Open Questions
- Monitor if disabling lift creates too much noise (lots of intermediate observables)
- Consider: use structural hash to optimize - if fn-only change, just swap fn_refs without full re-sub?

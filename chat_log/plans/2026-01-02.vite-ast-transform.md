# Plan: Vite Plugin AST Transform + Defer Test

## Goal
1. Write test for defer/lazy factory behavior to nail down expected store state
2. Clean up non-v2 vite plugin files
3. Plan AST transform for user code instrumentation

## Phase 1: Defer Test (nail down behavior first)

Add test to `src/tracking/v2/hmr/4_module-scope.test.ts`:

```ts
describe("defer/lazy factory", () => {
  it("defer factory runs with subscription context", () => {
    const __$ = _rxjs_debugger_module_start("file:///defer-test.ts")

    const innerValues: number[] = []
    const fetch$ = __$("fetch$", () => defer(() => {
      // Factory runs at subscribe time
      return __$("inner", () => of(Math.random()))
    }))
    __$.end()

    // Two subscriptions
    fetch$.subscribe(v => innerValues.push(v))
    fetch$.subscribe(v => innerValues.push(v))

    // Each subscription should get independent value
    expect(innerValues).toHaveLength(2)
    expect(innerValues[0]).not.toBe(innerValues[1])

    // Snapshot the store to understand current behavior
    expect(state$.value.store.hmr_track).toMatchInlineSnapshot(`???`)
  })

  it("sync observable (of) completes before subscribe-call-return", () => {
    const __$ = _rxjs_debugger_module_start("file:///sync-test.ts")

    const timeline: string[] = []
    const obs$ = __$("obs$", () => of(1, 2, 3))
    __$.end()

    obs$.subscribe({
      next: v => timeline.push(`next:${v}`),
      complete: () => timeline.push("complete"),
    })

    // All happens synchronously
    expect(timeline).toMatchInlineSnapshot(`
      [
        "next:1",
        "next:2",
        "next:3",
        "complete",
      ]
    `)
  })
})
```

**Expected behavior to verify:**
- [ ] `send` stack has subscription context during sync callbacks
- [ ] `subscription` stack is populated during defer factory (before send)
- [ ] Each defer subscription gets scoped track key (or shares appropriately)
- [ ] Store state is correct after multiple subscriptions

## Phase 2: Cleanup

Delete non-v2 vite plugin files:
- `src/vite-plugin/rxjs-track-plugin.ts`
- `src/vite-plugin/__tests__/rxjs-track-plugin.test.ts`
- `src/vite-plugin/index.ts`
- `src/vite-plugin/auto-class-decorate.ts` (check if used first)

Keep:
- `src/vite-plugin/v2.ts`
- `src/vite-plugin/__tests__/v2.test.ts`

## Phase 3: Understand Current `__$` Function Behavior

From `0_runtime.ts` lines 36-43:
```ts
const send = state$.value.stack.send.at(-1)
const hasSubscriptionPrefix = state$.value.stack.hmr_track.some(t => t.id.startsWith("$ref["))
const effectiveLocation = send && !hasSubscriptionPrefix
  ? `$ref[${send.observable_id}]:subscription[${send.subscription_id}]:${location}`
  : location
```

**Issue:** Only checks `send` stack, but defer factory runs before any `send`.

**Potential fix:** Also check `subscription` stack:
```ts
const send = state$.value.stack.send.at(-1)
const sub = state$.value.stack.subscription.at(-1)
// If we're in a subscription (even before send), scope by subscription
const subscriptionContext = send?.subscription_id ?? sub?.id
const effectiveLocation = subscriptionContext && !hasSubscriptionPrefix
  ? `$ref[${sub?.observable_id ?? send?.observable_id}]:subscription[${subscriptionContext}]:${location}`
  : location
```

## Phase 4: AST Transform Design (after tests pass)

**Files to modify:**
- `src/vite-plugin/v2.ts` - add user code transform

**Detection rules:**
1. RxJS creators: call to imported name from `rxjs` (of, from, defer, etc.)
2. RxJS classes: `new Subject()`, `new BehaviorSubject()`, etc.
3. `.pipe()` calls: any `.pipe` member call
4. `.subscribe()` calls: any `.subscribe` member call

**Transform pattern:**
```ts
// Input
import { of, map } from 'rxjs'
const data$ = of(1, 2, 3)
data$.subscribe(console.log)

// Output
import { _rxjs_debugger_module_start } from 'rxjs-debugger/hmr'
const __$ = _rxjs_debugger_module_start(import.meta.url)
import { of, map } from 'rxjs'
const data$ = __$("data$:HASH", () => of(1, 2, 3))
__$("sub:HASH", () => data$.subscribe(console.log))
__$.end()
```

**Key generation:**
- Content hash of AST subtree (stable across line number changes)
- Format: `${varName ?? nodeName}:${hash}`

**Function detection:**
- Walk AST to find functions containing RxJS expressions
- Runtime already wraps function results (lines 61-66 of `0_runtime.ts`)
- No special AST handling needed - just wrap the expression

## Resolved Questions

1. **Should defer's inner tracks be scoped by subscription ID?**
   YES - otherwise keys wouldn't be unique across subscriptions

2. **What happens when HMR changes the hash - do scoped tracks get cleaned up?**
   YES - old track key dies (hash differs), orphan cleanup completes all subs on that dead observable

3. **Is `subscription` stack the right context source for factory scoping?**
   YES - `subscription` is on stack during defer factory (before send)

## Files to Modify

1. `src/tracking/v2/hmr/4_module-scope.test.ts` - add defer tests
2. `src/tracking/v2/hmr/0_runtime.ts` - potentially fix subscription scoping
3. `src/vite-plugin/v2.ts` - add user code AST transform
4. Delete: `rxjs-track-plugin.ts`, `index.ts`, `auto-class-decorate.ts`, related tests

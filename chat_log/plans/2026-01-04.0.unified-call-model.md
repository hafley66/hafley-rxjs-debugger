# Relational Data Model Normalization & Full Unification Plan

## Executive Summary

**Full unification**: 11 tables → 5 tables (3 core + 2 HMR)

Everything collapses into `call` + `arg`:
- `operator_fun`, `operator`, `pipe`, `arg_call`, `send`, `subscription` → `call` with `kind` discriminator
- `arg` unchanged
- `observable` unchanged
- `hmr_track`, `hmr_module` unchanged

---

## Part 1: Final Minimal Model

### Core Tables: 3 + 2 HMR = 5 total (down from 11!)

```typescript
// OBSERVABLE - a source of values
type Observable = {
  id: string
  created_at: number
  obs_ref?: WeakRef<Observable>
  // name DERIVABLE from creation call's args
}

// CALL - everything is a call
type Call = {
  id: string
  created_at: number
  created_at_end?: number

  kind: "factory" | "operator" | "pipe" | "callback" | "subscribe" | "unsubscribe" | "next" | "error" | "complete"

  parent_id?: string              // FK → call (nesting)
  subscription_id?: string        // FK → call WHERE kind='subscribe' (runtime context)
  observable_id?: string          // FK → observable (denorm for query efficiency)
  index?: number                  // position in pipe

  // Subscribe-specific (when kind='subscribe')
  is_sync?: boolean
  sub_ref?: WeakRef<Subscription>
  module_id?: string              // FK → hmr_module
}

// ARG - argument positions + values
type Arg = {
  id: string
  created_at: number
  call_id: string                 // FK → call
  path: string                    // "$args.0", "$return", "$args.0.next"
  index: number                   // numeric

  // Value (one of these)
  value?: unknown
  observable_id?: string          // FK → observable
  fn_ref?: WeakRef<Function>
}

// HMR_TRACK, HMR_MODULE - unchanged
```

### What Collapsed

| Before | After | Notes |
|--------|-------|-------|
| `operator_fun` | `call(kind="factory")` | map(fn), filter(pred) |
| `operator` | `call(kind="operator")` | application in pipe |
| `pipe` | `call(kind="pipe")` | pipe is a factory |
| `arg_call` | `call(kind="callback")` | runtime function invocation |
| `send` | `call(kind="next/error/complete")` | emissions |
| `subscription` | `call(kind="subscribe")` | **FULLY COLLAPSED** |
| `arg` | `arg` | unchanged |
| `observable` | `observable` | unchanged |

### The 6 Lifecycle Events (tap semantics)

All siblings in the subscription state machine:
1. **subscribe** - creates subscription, has sub_ref
2. **next** - value emission
3. **error** - error emission
4. **complete** - completion
5. **unsubscribe** - explicit unsubscription
6. (finalize derivable from complete+unsubscribe timing)

### Key Queries

**All sends for subscription X:**
```sql
SELECT * FROM call
WHERE kind IN ('next','error','complete')
AND subscription_id = ?
```

**Find unsubscribe for subscription X:**
```sql
SELECT * FROM call
WHERE kind = 'unsubscribe'
AND subscription_id = ?
```

**Active subscriptions (not unsubscribed):**
```sql
SELECT s.* FROM call s
LEFT JOIN call u ON u.subscription_id = s.id AND u.kind = 'unsubscribe'
WHERE s.kind = 'subscribe' AND u.id IS NULL
```

**All subscriptions to observable X:**
```sql
SELECT * FROM call
WHERE kind = 'subscribe'
AND observable_id = ?
```

### Normalization Analysis

**Functional Dependencies:**

| FD | Analysis |
|----|----|
| `call.id → all call fields` | Primary key |
| `arg.id → all arg fields` | Primary key |
| `(arg.call_id, arg.path) → arg.id` | YES - candidate key |

**Nullable FKs are NOT denormalization** - they represent orthogonal dimensions:
- `subscription_id` = runtime context (which subscription we're inside)
- `parent_id` = nesting (call inside call)
- `observable_id` = target observable (denorm for query efficiency)

### The $path Convention

```
$args.0              - first argument
$args.1              - second argument
$return              - return value
$args.0.next         - the 'next' method of first arg (observer)
$args.0.next.$args.0 - value passed to observer.next
```

### Example: Nested Pipe Data

```typescript
source$.pipe(switchMap(inner => inner.pipe(map(x => x * 2))))
```

```
call#1: { kind: "factory" }  // map(fn)
  arg: { path: "$args.0", fn_ref: x=>x*2 }

call#2: { kind: "factory" }  // switchMap(fn)
  arg: { path: "$args.0", fn_ref: callback }

call#3: { kind: "pipe", observable_id: source$ }  // outer pipe
call#4: { kind: "operator", subscription_id: null, index: 0 }  // switchMap applied
  arg: { path: "$args.0", observable_id: source$ }
  arg: { path: "$return", observable_id: switchMap$ }

--- runtime ---

call#5: { kind: "subscribe", observable_id: switchMap$ }  // user subscribes
call#6: { kind: "callback", subscription_id: #5 }  // switchMap callback fires
call#7: { kind: "pipe", subscription_id: #5 }  // inner pipe (has sub context!)
call#8: { kind: "operator", subscription_id: #5, index: 0 }  // map applied in callback
  arg: { path: "$return", observable_id: mapped$ }
```

Key: `call#7` and `call#8` have `subscription_id` - they're parse-time operations happening during runtime.

---

## Part 2: State Mutation Violations

### Violation 1: `hmr/2_tracked-observable.ts` (HIGH SEVERITY)
**Lines 60-61, 76-77** - Direct stack push/pop during `connectToSource`:
```typescript
state$.value.stack.hmr_module.push(module)
state$.value.stack.hmr_track.push(trackCopy)
// ...
state$.value.stack.hmr_track.pop()
state$.value.stack.hmr_module.pop()
```

**Problem**: Bypasses event system. Stack mutations during reconnection.

**Can we use existing events?** No — this is a "context restoration" operation, not a new track. We need intent.

**Fix options:**
1. New events: `hmr-context-push` / `hmr-context-pop` (explicit intent)
2. Refactor to pass context as callback arg instead of global stack

### Violation 2: `0_test-utils.ts` (MEDIUM)
Direct stack manipulation for test scaffolding.

**Fix**: Use existing `track-call`/`track-call-return` events with test IDs.

### Violation 3: `hmr/0_runtime.ts` (LOW - reads only)
Direct `state$.value` reads during `__$()`.

**Assessment**: Reads acceptable. Context derivation from stack is the pattern.

## Part 3: Bug Found

### `06_queries.ts:92` - Invalid field reference

```typescript
const liveObsIds = new Set(Object.values(store.hmr_track).map(t => t.entity_id))
// WRONG: should be t.mutable_observable_id
```

---

## Part 4: Implementation Plan

### Phase 1: Foundation (Do First)

**Task 1.1**: Fix `entity_id` bug in `06_queries.ts:92`

**Task 1.2**: Create unified `call` and `arg` types
- Rename in `Hmm` type: `operator_fun` → use as `call`, `arg_call` → merge into `call`
- Add fields: `parent_id`, `pipe_id`, `subscription_id`, `kind`, `index`
- Keep `arg` but add `call_id` FK (rename from `owner_id`)

### Phase 2: Collapse Entities

**Task 2.1**: Merge `operator_fun` into `call`
- Update `operator-fun-call` handler to create `call` record
- Args already belong to calls via `owner_id` → `call_id`

**Task 2.2**: Merge `operator` into `call`
- `operator-call` creates `call` with `pipe_id`, `index`
- Args: `$args.0` = source_observable, `$return` = target_observable
- Remove `state.store.operator`

**Task 2.3**: Rename `arg_call` to just use `call`
- Runtime callbacks are `call` with `subscription_id` set
- Keep `parent_id` for nesting

**Task 2.4**: Merge `send` into `call` (optional, can defer)
- Add `kind: "next" | "error" | "complete"` field
- `send-call` creates `call` with kind and subscription_id
- Arg `$args.0` holds the value

### Phase 3: Remove Redundancy

**Task 3.1**: Remove `pipe.observable_id`
- Delete field from type
- Add helper: `getPipeOutput(pipe_id) → observable_id`

**Task 3.2**: Remove `operator_fun`, `operator`, `arg_call` entity types
- Update state initialization
- Update all references

### Phase 4: Event Consolidation

**Task 4.1**: Consolidate events to `call-call` / `call-call-return`
- Or keep existing event names, map to unified `call` in accumulator
- Decision: Keep existing names for now (less churn)

### Phase 5: Tests & Validation

**Task 5.1**: Write nested pipe test
```typescript
source$.pipe(
  switchMap(inner => inner.pipe(map(x => x * 2)))
)
```
- Verify call records have correct `pipe_id` + `subscription_id`
- Verify `$return` args have correct `observable_id`

**Task 5.2**: Verify queries still work
- `getDanglingSubscriptions`
- `getPipeOutput`
- Any render-tree queries

### Phase 6: State Mutation Purity (Separate PR)

**Task 6.1**: Fix `2_tracked-observable.ts` direct mutations
- Pass context as params to `connectToSource`
- No global stack manipulation

**Task 6.2**: Fix `0_test-utils.ts` direct mutations
- Use real events or test harness

---

## Files to Modify

| File | Phase | Changes |
|------|-------|---------|
| `src/tracking/v2/00.types.ts` | 1,2,3 | Unified types, remove old entities |
| `src/tracking/v2/03_scan-accumulator.ts` | 2,3 | Unified handlers |
| `src/tracking/v2/06_queries.ts` | 1,3 | Bug fix, new helpers |
| `src/tracking/v2/hmr/0_runtime.test.ts` | 5 | Nested pipe test |
| `src/tracking/v2/hmr/2_tracked-observable.ts` | 6 | Context passing |
| `src/tracking/v2/0_test-utils.ts` | 6 | Event-based setup |

---

## Migration Strategy

1. **Incremental**: Don't delete old fields immediately, add new ones first
2. **Dual-write**: Accumulator writes to both old and new fields during transition
3. **Verify**: Run all tests after each phase
4. **Cleanup**: Remove old fields once stable

---

## Open Questions Resolved

**Q: Keep event names or rename?**
**A: Keep existing event names** (`operator-fun-call`, `operator-call`, etc.) - they describe the source context. The accumulator maps them to unified `call` records. Less churn, clear semantics.

**Q: Return value - arg or field on call?**
- `$return` as arg keeps uniform model (all values in arg table)
- Could add `return_observable_id` / `return_ref` to call for perf
- **Decision**: Keep as arg for now, revisit if query perf matters

**Q: subscription_id vs just using parent_id from stack?**
- You can be in send→next callback and call subscribe()
- That subscribe's parent on stack = the send call, not the subscription
- **Decision**: Need explicit `subscription_id` for runtime context

**Q: observable_id uses by kind:**
- `pipe`, `subscribe`, `unsubscribe`: target observable (method was called ON it)
- `next`, `error`, `complete`: duplicative with subscription's observable but query-friendly
- `factory`: doesn't have (no observable target)
- `operator`: in `$args.0` (source) and `$return` (target)

**Q: is_sync determination:**
- Derivable from return type or call timing (returns before call-return event)
- Could check `$return` arg type

---

## Critical: Two Stacks for Context Derivation

**parent_id ≠ subscription_id** - they come from different stacks:

### Call Stack → parent_id
- Structural nesting (call inside call)
- Push on call-call, pop on call-call-return
- Example: tap callback's parent_id = tap call

### Subscription Stack → subscription_id
- Runtime context (which subscription we're executing in)
- Push when subscribe call happens
- Pop when that subscription completes/errors/unsubscribes
- List of call_ids WHERE kind='subscribe'

### Why both are needed:
```typescript
source$.pipe(
  tap(() => {
    // Here: subscription_id = outer sub, parent_id = tap callback
    other$.pipe(map(...)).subscribe()  // pushes NEW sub to sub stack
  })
).subscribe()  // outer sub
```

The inner `.pipe(map(...))` has:
- `parent_id` = tap callback call (from call stack)
- `subscription_id` = the NEW inner subscription (from sub stack, not outer!)

### Unsubscribe handling:
- `unsubscribe.subscription_id` = the subscription being unsubscribed
- Derived from subscription stack at time of unsubscribe call

---

## Open for Future Discussion

### Pipe observable_id question
- `pipe-get` creates `call { kind: "pipe", id: X }`
- Should `pipe.observable_id` be:
  - A) Input observable (source$) - what pipe was called ON
  - B) Output observable (last op's $return) - what pipe PRODUCES
  - C) Neither - let `$return` arg naturally express output
- Current thinking: A) for input, C) for output via arg

### Root observables query
- "Root" = observables not produced by any operator
- Query: `SELECT * FROM observable WHERE NOT EXISTS (SELECT 1 FROM arg WHERE path='$return' AND observable_id=observable.id)`

### Root subscriptions query
- "Root" = subscriptions with no parent_subscription_id
- Query: `SELECT * FROM call WHERE kind='subscribe' AND parent_id IS NULL`

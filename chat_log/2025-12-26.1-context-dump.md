# Context Dump: Task 02 Complete, Pre-Testing
**Timestamp:** 2025-12-26 (Session 1)
**Status:** Task 02 ‚úì Complete, Ready for Testing & Type Fixes

---

## What We Built (Task 02)

### Files Created/Modified
1. **src/tracking/types.ts** ‚úì
   - ObservableMetadata with dynamic context fields
   - SubscriptionMetadata with execution tracking
   - Emission, ErrorEvent for animation
   - OperatorExecutionContext (THE KEY type for context stack)
   - PipeContext, SubscriptionContext
   - ArgumentRelationship with `.$return` sigil

2. **src/tracking/storage.ts** ‚úì
   - Localforage (8KB) instead of raw IndexedDB
   - RxJS batching with `bufferTime(100)`
   - Direct access via `writeQueue$.next()`
   - Typed stores for each entity type

3. **src/tracking/registry.ts** ‚úì
   - **operatorContext** stack (push/pop/peek) - Observable constructor checks this!
   - pipeContext & subscriptionContext stacks
   - Emission/error recording
   - Argument relationship tracking
   - All ID generators

4. **src/tracking/observable-wrapper.ts** ‚úì
   - OObservable extends RxJS Observable
   - Constructor checks `operatorContext.peek()` for dynamic vs static
   - Exported as `Observable` for drop-in replacement
   - Always registers observables
   - Queues writes to storage

5. **src/tracking/config.ts** ‚úì
   - Global hook: `window.__RXJS_DEVTOOLS_GLOBAL_HOOK__`
   - Enable/disable tracking flag
   - Always register observables (pipe-time)
   - Conditionally track subscribe-time (emissions, subscriptions)
   - Enabled by default

6. **Tests Created** ‚úì
   - `__tests__/observable-wrapper.test.ts`
   - `__tests__/config.test.ts`

### Dependencies Added
```json
"dependencies": {
  "localforage": "^1.10.0",
  "rxjs": "^7.8.1"
}
```

---

## Key Architecture Decisions

### 1. Context Stack Pattern
```typescript
// THE MAGIC: Observable constructor checks context
const ctx = operatorContext.peek();

if (!ctx) {
  // Empty stack = pipe/module time (static)
  metadata.createdByOperator = undefined;
} else {
  // Stack has entries = subscribe time (dynamic)
  metadata.createdByOperator = ctx.operatorName;
  metadata.triggeredBySubscription = ctx.subscriptionId;
}
```

### 2. Storage Strategy
- **Brute force + IndexedDB** via localforage
- RxJS batching every 100ms
- Always register observables (cheap)
- Conditionally track execution (expensive)

### 3. Three "Times" Philosophy
1. **Pipe Time** - Observable creation (static structure)
2. **Subscribe Time** - Execution flows (dynamic tree)
3. **Argument Time** - Cross-observable relationships

### 4. Intertwined Execution
Subscribe-time can contain pipe calls:
```typescript
source$.pipe(
  switchMap(x => {
    // We're at subscribe-time now
    // operatorContext has switchMap pushed
    return of(x).pipe(map(y => y * 2));  // NEW pipe call!
    // Inner observable checks stack, sees switchMap context
  })
)
```

---

## Task 03 Analysis & Adaptations

### What Task 03 Requires
**File:** `src/tracking/pipe-patch.ts`

**Goal:** Monkey-patch `Observable.prototype.pipe` to:
1. Capture operator chains
2. Build parent-child relationships
3. Track operator instances (each call gets unique ID)
4. Crawl operator arguments for observables
5. Register ArgumentRelationships
6. Support lodash-style argument paths

### Alignment Check: What We've Built vs What Task 03 Needs

#### ‚úì Already Have
- Context stacks (operatorContext, pipeContext, subscriptionContext)
- ObservableMetadata with operators array
- Parent WeakRef pattern
- Path generation strategy
- ArgumentRelationship types
- Registry functions (registerObservable, getMetadata)
- Operator instance ID generator

#### ‚ö†Ô∏è Missing for Task 03
1. **Pipe patching** - Need to actually patch Observable.prototype.pipe
2. **Operator name extraction** - getOperatorName() helper
3. **Argument crawling** - Find observables in operator args (lodash traversal)
4. **Function wrapping** - Detect `.$return` observables
5. **Operator decoration** - Wrap operators to push context on next/error/complete

### Task 03 Assumptions to Update

#### Original Assumption (from task-03-context.md):
> "Task 4 is simultaneously working on subscribe patching"

#### Updated Reality:
- We're doing tasks sequentially, not in parallel
- Task 02 (Observable wrapper) is complete
- No risk of conflicts - we control the timeline
- Can coordinate between pipe-patch and subscribe-patch

#### Original Assumption:
> "Operator instance tracking works (same operator, multiple uses)"

#### Updated Reality Based on Architecture Discussion:
- **No per-usage operator instance IDs** at pipe time
- Operators decorated ONCE at init time
- Pipe calls create context (pipeGroupId)
- Operator instances tracked at **subscribe time** (operatorInstanceId in OperatorExecutionContext)

#### Path Generation (Already Aligned):
```typescript
// Task says:
// Root: path = String(operatorCount)
// Child: path = `${parent.path}.${operatorCount}`

// We have in types.ts:
interface ObservableMetadata {
  path: string;  // "0.2.1" format
  pipeGroupId?: string;  // Which .pipe() call
}
```

---

## Next Steps (Task 03 Implementation)

### 1. Pipe Patching
```typescript
// Store original
const originalPipe = Observable.prototype.pipe;

// Patch it
Observable.prototype.pipe = function(...operators) {
  // Push pipe context
  pipeContext.push({ pipeId, sourceObsId, operators });

  // Call original
  const result = originalPipe.apply(this, operators);

  // Register result with metadata
  registerObservable(result, metadata);

  // Pop context
  pipeContext.pop();

  return result;
};
```

### 2. Operator Decoration (Generic)
```typescript
function decorateOperator(operator) {
  return function(...args) {
    const decorated = operator(...args);

    // Return OperatorFunction that wraps subscriber
    return (source) => {
      return new Observable(subscriber => {
        const proxiedSubscriber = {
          next: (value) => {
            operatorContext.push({ operatorName, event: 'next', value });
            subscriber.next(value);
            operatorContext.pop();
          },
          error: (err) => { /* similar */ },
          complete: () => { /* similar */ }
        };

        return source.subscribe(proxiedSubscriber);
      });
    };
  };
}
```

### 3. Argument Crawling
```typescript
function crawlArguments(operator, args) {
  // Use lodash _.isPlainObject, _.isArray
  // Wrap functions to detect .$return observables
  // Build ArgumentRelationship with paths
}
```

### 4. Integration Point
```typescript
// App entry:
import { Observable } from './tracking/observable-wrapper';
import { patchPipe } from './tracking/pipe-patch';

patchPipe();  // Patch Observable.prototype.pipe

// Now user code runs with tracked observables
```

---

## Critical Dependencies

### For Task 03, We Need:
- ‚úì lodash (for argument crawling) - **TODO: Add to package.json**
- ‚úì operatorContext from registry
- ‚úì pipeContext from registry
- ‚úì registerObservable from registry
- ‚úì generateObservableId from registry
- ‚úì generateOperatorInstanceId from registry
- ‚úì registerArgumentRelationship from registry
- ‚úì ObservableMetadata type
- ‚úì ArgumentRelationship type

### Type Issues to Fix:
- Check SubscriptionMetadata initialization (emissionIds, errorIds arrays)
- Verify ArgumentRelationship Map serialization
- Ensure all types are exported correctly

---

## Testing Strategy

### Current Tests:
- observable-wrapper.test.ts - Tests Observable creation and context checking
- config.test.ts - Tests configuration management

### Need for Task 03:
- pipe-patch.test.ts - Test pipe patching, operator chains, paths
- Verify no conflicts between pipe patch and Observable wrapper
- Test nested pipes with context stacks
- Test argument crawling and relationship registration

---

## Open Questions

### 1. Operator Decoration Timing
**Question:** When do we decorate operators?
**Answer:** At init time, before user code runs. Decorate once per operator.

### 2. Pipe vs Subscribe Context
**Question:** How do contexts interact?
**Answer:**
- pipeContext tracks static structure (which .pipe() call)
- operatorContext tracks dynamic execution (which event firing)
- subscriptionContext tracks which subscription is running
- All three can be active simultaneously (nested)

### 3. Memory Management
**Question:** Argument relationships use Map - how to clean up?
**Answer:**
- ArgumentRelationship stored in localforage (persistent)
- In-memory reverse index (observableUsedIn) for queries
- Consider WeakMap if possible, or periodic cleanup

---

## Current State Summary

### ‚úì Complete
- Observable wrapper with context checking
- Storage layer with batching
- Registry with context stacks
- Configuration system
- Type definitions
- Basic tests

### üöß Next (Task 03)
- Pipe patching
- Operator decoration
- Argument crawling
- Path generation implementation
- Comprehensive tests

### ‚è≥ Future (Task 04+)
- Subscribe patching
- Emission tracking
- Error tracking
- Debugger API
- Special operators (switchMap, mergeMap, etc.)

---

## Known Issues / Tech Debt

1. **No lodash yet** - Need to add for argument crawling
2. **Stack trace parsing** - Works but could be more robust
3. **Type exports** - May need to verify all types are properly exported
4. **Circular buffer for emissions** - Not implemented yet (Task 04)
5. **Extension storage adapter** - Placeholder only

---

## Success Metrics

### Task 02 Goals ‚úì
- [x] Track observable creation
- [x] Distinguish pipe-time from subscribe-time
- [x] Context stacks working
- [x] Storage layer operational
- [x] Configuration system in place
- [x] Tests written

### Task 03 Goals (Upcoming)
- [ ] Pipe method patched
- [ ] Operator chains captured
- [ ] Parent-child relationships built
- [ ] Argument relationships tracked
- [ ] Paths generated correctly
- [ ] Tests passing

---

**End of Context Dump**

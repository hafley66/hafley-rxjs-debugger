# Chat Log: RxJS Devtools Architecture Discussion
**Date:** 2025-12-26
**Session:** 0
**Topic:** Architecture design and planning for Task 02 implementation

---

## Summary

Comprehensive architecture discussion for RxJS devtools tracking system. Established the "three times" philosophy (pipe/subscribe/argument), designed context stack patterns, and created full documentation including a detailed `repeat` operator walkthrough.

---

## Key Decisions

### 1. Three "Times" Architecture
- **Pipe Time**: Observable creation (static structure)
- **Subscribe Time**: Subscription execution (dynamic tree)
- **Argument Time**: Cross-observable relationships (observables as operator args)

### 2. Four Context Stacks
```typescript
globalContext = {
  pipeStack: [],              // Which .pipe() call we're in
  subscriptionStack: [],      // Which subscription is executing
  operatorStack: [],          // Which operator event (next/error/complete)
  // functionStack: []        // Future: which wrapped function
}
```

### 3. Operator Decoration Pattern
- **Decorate operators ONCE** at init time: `decorate(switchMap)` uses `func.name`
- Operators are **stateless** - the pipe call creates the context
- **No per-usage operator instance IDs** - pipe grouping provides structure
- Generic decorator intercepts next/error/complete events, sets context

### 4. Argument Path Convention
Use lodash-style paths with **`.$return` sigil** (not `()`):
- `"0"` - Direct parameter
- `"0.delay"` - Object property
- `"0.delay.$return"` - Function return (lodash-compatible)
- `"0[1]"` - Array element

### 5. Pipe Call = Event/Closure
Trap `.pipe` getter to wrap calls:
```typescript
Object.defineProperty(Observable.prototype, 'pipe', {
  get() {
    return function wrappedPipe(...operators) {
      pipeContext.push({ pipeId, sourceObsId, operators });
      try {
        return originalPipe.apply(this, operators);
      } finally {
        pipeContext.pop();
      }
    };
  }
});
```

### 6. Observable Constructor Context Checking
```typescript
class Observable {
  constructor(subscribe) {
    super(subscribe);
    const ctx = operatorContext.peek();  // Check stack

    const metadata = {
      // ... static fields ...

      // If ctx exists -> dynamic/subscribe-time creation
      // If ctx is null -> pipe/module-time creation
      createdByOperator: ctx?.operatorName,
      triggeredBySubscription: ctx?.subscriptionId,
      triggeredByObservable: ctx?.observableId,
      triggeredByEvent: ctx?.event,
    };
  }
}
```

### 7. Bidirectional Linking
- **Forward**: Observable → parent observable (via pipe chain)
- **Backward**: Subscription → triggering observable + operator (via context)
- **Lateral**: Observable → argument observables (via ArgumentRelationship)

### 8. Memory Management
- Observable metadata: `WeakMap` (auto-cleanup)
- Subscription metadata: `Map` (strong refs while active)
- Operator refs: `WeakRef` (allow GC)
- Context stacks: Plain arrays (cleared after use)
- All IDs are strings (serializable)

### 9. Proxying Observable at Dev Time
Avoid circular dependencies:
```typescript
// vite.config.ts
resolve: {
  alias: {
    'rxjs': './src/tracking/rxjs-proxy.ts'
  }
}
```

Internal tracking code imports from `rxjs/dist/...` (original).

### 10. Use Lodash for Power
Use lodash `get`, `set`, `transform` for recursive argument crawling and path manipulation.

---

## Architecture Highlights

### Universal Context Pattern
Instead of special-casing operators, **generically intercept all events**:

```typescript
function decorate(operatorFn) {
  const operatorName = operatorFn.name;

  return (...args) => {
    const { observables, wrappedArgs } = crawlArguments(args, operatorName);
    const impl = operatorFn(...wrappedArgs);

    return (source) => new Observable(subscriber => {
      return impl(source).subscribe({
        next: (value) => {
          operatorContext.push({ operatorName, subscriptionId, observableId, event: 'next', value });
          try { subscriber.next(value); }
          finally { operatorContext.pop(); }
        },
        // ... error, complete similar
      });
    });
  };
}
```

**Key insight**: Any observable created while context is active gets automatically linked!

### Observable Tree Structure (DOM-like)
```
source$ (obs#1)
  └─ pipe#1 [map, filter]
     └─ result$ (obs#2)
        └─ pipe#2 [switchMap]
           └─ switched$ (obs#3)
```

Pipe groups provide structure without needing operator instance IDs.

---

## repeat({ delay: () => timer(1000) }) Walkthrough

### Pipe Time
1. `interval(500).pipe(take(3))` creates obs#1, obs#2
2. `.pipe(repeat({ delay: () => timer(1000) }))` creates obs#3
3. Delay function is **wrapped** (captures closure)
4. No observables created from delay yet

### Subscribe Time
1. `result$.subscribe()` creates sub#1 → sub#2 → sub#3
2. interval starts emitting: 0, 1, 2
3. take completes

### Operator Event (Complete)
1. repeat's complete handler fires
2. **Context pushed**: `{ operator: 'repeat', subId: 'sub#2', obsId: 'obs#2', event: 'complete' }`
3. repeat calls `delay()` → returns `timer(1000)`
4. **Observable constructor checks context** → marks timer with:
   - `createdByOperator: 'repeat'`
   - `triggeredBySubscription: 'sub#2'`
   - `triggeredByEvent: 'complete'`
   - `argumentPath: '0.delay.$return'`
5. Context popped
6. repeat subscribes to timer
7. Timer completes → repeat resubscribes to source
8. **Each iteration creates NEW timer observable** (obs#4, obs#5, ...)

---

## Documents Created

1. **ARCHITECTURE.md**: Full architecture with context stacks, patterns, memory management
2. **REPEAT-WALKTHROUGH.md**: Step-by-step execution trace with state at each phase
3. **tasks/task-02-observable-wrapper.md**: Updated with enhanced types and architecture
4. **tasks/task-03-pipe-patch-UPDATED.md**: New task file with generic operator decoration

---

## Debugger Views

### Current View (Live Snapshot)
Shows active subscriptions mixed with pipe tree structure - like Chrome Elements panel.

### Time-Travel View
- Scrub timeline to any moment
- Select observable/subscription → see full history
- Like React DevTools for components

---

## Implementation Priority

### Task 02 (Next)
Create foundational tracking infrastructure:
- Enhanced `types.ts` with all metadata types
- `registry.ts` with context stacks and storage
- `observable-wrapper.ts` checking context in constructor

### Task 03
- Generic operator decorator
- Pipe getter trap
- Argument crawler with lodash

### Task 04
- Subscribe patching
- Subscription context stack
- Emission tracking

---

## Open Questions (None)
All architecture questions resolved. Ready for implementation.

---

## Code Snippets Reference

### Context Stack (Simple)
```typescript
const operatorContextStack: OperatorExecutionContext[] = [];

export const operatorContext = {
  push: (ctx) => operatorContextStack.push(ctx),
  pop: () => operatorContextStack.pop(),
  peek: () => operatorContextStack[operatorContextStack.length - 1],
};
```

### Argument Path Examples
```typescript
"0"                    // withLatestFrom(other$)
"0[0]"                 // combineLatest([a$, b$]) - first element
"0.delay.$return"      // repeat({ delay: () => timer() })
"0.notifier.$return"   // retryWhen(errors$ => errors$.pipe(...))
```

### Observable Metadata (Enhanced)
```typescript
interface ObservableMetadata {
  id: string;
  createdAt: string;
  location: { filePath, line, column };
  variableName?: string;
  parent?: WeakRef<any>;
  operators: string[];
  path: string;
  pipeGroupId?: string;

  // Dynamic context (undefined = pipe-time, set = subscribe-time)
  createdByOperator?: string;
  triggeredBySubscription?: string;
  triggeredByObservable?: string;
  triggeredByEvent?: 'next' | 'error' | 'complete';
  argumentPath?: string;
}
```

---

## Next Steps

1. Implement Task 02 with enhanced types from updated task file
2. Create tests validating context stack behavior
3. Move to Task 03 for operator decoration

---

**Session End**: Ready for implementation

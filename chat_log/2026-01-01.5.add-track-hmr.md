# RxJS HMR Instrumentation - Phase 1 Batch 2 Complete

## Goal

Build an HMR system for RxJS that mirrors React's pattern: keep subscriptions alive, swap function args on code change, next emission flows through new code naturally.

## Current State

- **Branch**: `feature/vite-instrumentation-v2`
- **Working**: Core tracking system + HMR types + runtime + accumulator handlers + tests passing
- **Plan file**: `/Users/chrishafley/.claude/plans/jazzy-juggling-sparrow.md`

## Solution/Approach

Phase 1 implemented in batches:
- Batch 1: Types and state infrastructure (DONE)
- Batch 2: Runtime + accumulator handlers + tests (DONE - this session)
- Batch 3: Additional tests / edge cases

Key architecture:
- `hmr_track` is 1:1 with entity, references via `entity_id`
- Track context lives on `state$.stack.hmr_track` (NOT a separate module variable)
- Events follow local consistency: `track-call` / `track-call-return`
- Parent track inferred from stack peek
- `__$` wraps function returns to re-invoke `__$` on each call (React-style)

## Tasks

Completed:
- [x] Add `hmr_track` to `Hmm` type in `00.types.ts`
- [x] Add track event types to `ObservableEvent` union
- [x] Add `hmr_track` to `state$` initial value (stack + store)
- [x] Create `src/tracking/v2/hmr/0_runtime.ts` - `__$` implementation
- [x] Create `src/tracking/v2/hmr/1_queries.ts` - `deriveStructuralPath`
- [x] Add track event handlers to `03_scan-accumulator.ts`
- [x] Add entity capture in constructor/factory/pipe/operator handlers
- [x] Create `src/tracking/v2/hmr/0_runtime.test.ts` - 7 passing tests

Remaining (Phase 2):
- [ ] `track-update` event for HMR swap
- [ ] Vite transform to inject `__$` calls
- [ ] Integration tests with actual HMR

## Files Modified

- `src/tracking/v2/hmr/0_runtime.ts`:
  - `__$` function with nested `$` tracker
  - Function return wrapping (re-invokes `__$` on each call)

- `src/tracking/v2/03_scan-accumulator.ts`:
  - `track-call` handler: creates partial entity, pushes to stack
  - `track-call-return` handler: pops from stack, stores if entity captured
  - Added entity capture in: `constructor-call-return`, `factory-call-return`, `pipe-call-return`, `operator-fun-call`

## Files Created

- `src/tracking/v2/hmr/0_runtime.test.ts` - 7 passing tests

## Key Insights

1. **No separate module stack** - Use `state$.stack.hmr_track` for consistency with rest of system
2. **Last entity wins** - In a track scope, the last entity created gets associated
3. **Function return wrapping** - `__$` calls itself recursively when wrapping function returns
4. **Parent tracks may not be stored** - Only tracks with captured entities are stored; `parent_track_id` may reference non-existent track

## Test Results

All 7 tests pass:
1. tracks observable creation - `entity_type: "observable"`
2. tracks nested scopes - `parent_track_id: "root"` on child
3. tracks pipe - last entity in scope wins (`entity_type: "pipe"`)
4. wraps function returns - `undefined` on definition, populated after calls
5. stack peek works during scope
6. stack empty outside scope
7. tracks operator_fun - `entity_type: "operator_fun"`

## Open Questions

- Exact `track-update` semantics for Phase 2
- How Vite transform will generate unique structural path IDs
- Whether parent tracks without entities should be stored (currently not)

# Session: isEnabled$ Refactor and trackedObservable Fix

## Goal
Replace the old `track(true/false)` mechanism with a cleaner `isEnabled$` BehaviorSubject approach, and fix the trackedObservable HMR proxy to properly switch sources without closing subscriptions.

## Current State
- **Branch**: `feature/vite-instrumentation-v2`
- **Commit**: `5256263` - feat: replace track mechanism with isEnabled$ and add HMR tracking
- **Tests**: All 52 tests passing

## Problem/Context
1. **Infinite loop issue**: `trackedObservable` subscribes to `state$$` which triggers events, updating state, causing more callbacks - infinite loop
2. **Old track mechanism**: `track(true/false)` was redundant with hmr_track context check and cluttered the codebase
3. **Subscriber linking bug**: When passing `subscriber` directly to `sourceObs.subscribe(subscriber)`, RxJS links them via `subscriber.add()`. Unsubscribing the inner subscription then closes the outer subscriber.

## Solution/Approach

### 1. isEnabled$ Refactor
- Created separate `isEnabled$` BehaviorSubject (not tracked itself)
- Created `__withNoTrack<T>(fn: () => T): T` helper that:
  - Saves prev = isEnabled$.value
  - Sets isEnabled$.next(false)
  - Runs fn()
  - Restores isEnabled$.next(prev)
- Removed `track()`, `isTracking()` from `01_helpers.ts`
- Updated bootstrap to use `isEnabled$.value`
- Updated `observableEventsEnabled$` filter to use `isEnabled$.value`
- Removed `isEnabled` from State type (now separate)

### 2. trackedObservable Fix
- Wrap subscriber instead of passing directly:
```typescript
// BAD - links subscriber, unsubscribe closes it
innerSub = sourceObs.subscribe(subscriber)

// GOOD - no linking, unsubscribe only affects inner
innerSub = sourceObs.subscribe({
  next: v => subscriber.next(v),
  error: e => subscriber.error(e),
  complete: () => subscriber.complete(),
})
```

### 3. Event Filtering
- `shouldEmit()` checks:
  1. `isEnabled$.value` must be true
  2. UNTRACKED_EVENTS (track-*, send-*) always emit when enabled
  3. Other events require `trackStack.length > 0` (hmr_track context)
- Send events filtered in accumulator based on origin track existence

## Tasks
- [x] Create isEnabled$ BehaviorSubject
- [x] Create __withNoTrack() helper
- [x] Remove old track mechanism
- [x] Update bootstrap and refs
- [x] Fix trackedObservable subscriber linking
- [x] Update all tests to use isEnabled$.next()
- [x] Remove isEnabled from State type
- [x] All tests passing

## Files Modified
- `src/tracking/v2/00.types.ts` - Added isEnabled$, __withNoTrack, removed isEnabled from State
- `src/tracking/v2/01.patch-observable.ts` - Updated shouldEmit, bootstrap
- `src/tracking/v2/01_helpers.ts` - Removed track(), isTracking()
- `src/tracking/v2/03_scan-accumulator.ts` - Send filtering by origin track
- `src/tracking/v2/hmr/2_tracked-observable.ts` - Fixed subscriber wrapping
- `src/tracking/v2/**/*.test.ts` - Updated to use isEnabled$.next()

## Key Insights
1. **RxJS Subscriber Linking**: When you `subscribe(subscriber)` where subscriber is a Subscriber object, RxJS calls `subscriber.add(subscription)` internally. This means unsubscribing triggers teardown on the linked subscriber. Operators like `switchMap` work around this by manually forwarding next/error/complete.

2. **Separation of Concerns**: `isEnabled$` as separate BehaviorSubject keeps tracking control out of the main state tree, avoiding recursion issues when internal code needs to subscribe to state.

3. **Event Gating Strategy**: Two-layer filtering:
   - Runtime: `isEnabled$` + `trackStack.length` check in `shouldEmit()`
   - Accumulator: Send events filtered by origin track existence

## Open Questions
- None currently - implementation complete and tested

# RxJS HMR Instrumentation - Planning Round 1

## Goal

Build an HMR system for RxJS that mirrors React's pattern: keep subscriptions alive, swap function args on code change, next emission flows through new code naturally.

## Current State

- **Branch**: `feature/vite-instrumentation-v2`
- **Working**: Core tracking system (observable, operator_fun, operator, pipe, subscription, arg, arg_call, send entities)
- **Key files**:
  - `src/tracking/v2/00.types.ts` - Entity types, State, ObservableEvent
  - `src/tracking/v2/01.patch-observable.ts` - Runtime monkey-patching
  - `src/tracking/v2/03_scan-accumulator.ts` - Event → state mutations
  - `src/vite-plugin/v2.ts` - Build-time instrumentation

## Problem/Context

Desktop Claude session created detailed HMR plan (`chat_log/2026-01-01.2.plannng-for-hmr-layer.md`) without codebase access. Need to reconcile that plan with actual code structure.

Key insight: HMR track system is a **separate layer** on top of existing runtime. References core entities via `entity_id` but doesn't modify core model. Tags remain UI-only state.

## Solution/Approach

**6-phase roadmap**, implementing Phase 1 today:

1. **Manual `__$` Validation** ⬅️ TODAY - Add types, runtime, tests with handwritten instrumentation
2. **Swap Mechanism** - Prove HMR swap works
3. **Lifecycle Management** - Cascade delete, orphan sweep
4. **AST Pattern Catalog** - Document all patterns before parser
5. **Vite Plugin AST Transform** - Auto-transform with oxc/ast-grep (NOT Babel)
6. **Playwright Integration Tests** - E2E validation

**Key architecture decisions**:
- `__$` emits events, all mutations through scanEager (no direct store access)
- Stack-based tracking like other entities (no buffering)
- oxc/ast-grep for AST transforms (Rust toolchain, matches rolldown-vite)

## Tasks

Phase 1 implementation:
- [ ] Add `hmr_track` to `Hmm` type in `00.types.ts`
- [ ] Add track event types to `ObservableEvent` union
- [ ] Add `hmr_track` to `state$` initial value (stack + store)
- [ ] Create `src/tracking/v2/hmr/0_runtime.ts` - `__$` implementation
- [ ] Create `src/tracking/v2/hmr/1_queries.ts` - `deriveStructuralPath`
- [ ] Add track event handlers to `03_scan-accumulator.ts`
- [ ] Create `src/tracking/v2/hmr/0_runtime.test.ts` - validation tests

## Files to Modify

**Existing**:
- `src/tracking/v2/00.types.ts` - Add hmr_track type + events
- `src/tracking/v2/03_scan-accumulator.ts` - Add track event handlers

**New**:
- `src/tracking/v2/hmr/0_runtime.ts` - `__$`, TrackContext
- `src/tracking/v2/hmr/1_queries.ts` - `deriveStructuralPath`
- `src/tracking/v2/hmr/0_runtime.test.ts` - Manual tests

## Key Insights

1. **Existing infrastructure helps**: `tags?: string[]` already on all entities, `_tagContext` exists for scoped tagging
2. **Stack pattern**: `hmr_track` follows same stack+store pattern as other entities
3. **Event types needed**:
   - `track-scope-start` / `track-scope-end` - bracket `__$` callback execution
   - `track-register` - associate track with entity
   - `track-update` - HMR swap (bump version, move old to prev_entity_ids)
4. **No Babel**: Use oxc or ast-grep for Phase 5 AST transforms

## Open Questions

- Exact logic for correlating entities to tracks in `track-scope-end` handler
- How `$` child tracker passes index to children (position in parent scope)

## Plan File

Full detailed plan at: `/Users/chrishafley/.claude/plans/jazzy-juggling-sparrow.md`

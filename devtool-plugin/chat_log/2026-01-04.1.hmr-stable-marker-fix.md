# 2026-01-04 - hmr-stable-marker-fix

## Goal
Fix the TRACKED_MARKER timing issue so wrapper observables correctly set `stable_observable_id` instead of overwriting `mutable_observable_id`.

## Current State
- Branch: `feature/vite-instrumentation-v2`
- Unit tests passing (`0_runtime.test.ts`)
- Integration test fixture created at `src/vite-plugin/__tests__/hmr-integration/`
- Type added: `next_mutable_observable_id` on `hmr_track` (but naming is wrong - needs removal)

## Problem/Context

### The Core Issue
When `trackedBehaviorSubject` creates its proxy:
```typescript
const proxy = new BehaviorSubject(initialValue)  // constructor-call-return fires HERE
;(proxy as any)[TRACKED_MARKER] = true            // marker set AFTER
```

The accumulator's check `(event.observable as any)[TRACKED_MARKER]` is `false` because marker isn't set yet. So it sets `mutable_observable_id` instead of `stable_observable_id`, overwriting the inner's ID.

### Current Workaround (Bad - Violates Architecture)
`0_runtime.ts` directly mutates `state$`:
```typescript
trackOnStack.stable_observable_id = (stable as any).__id__
trackOnStack.mutable_observable_id = mutableIdBeforeWrapper  // restore
```
This bypasses the event/accumulator pattern. All state$ changes should go through scan accumulator.

### Key Definitions
- `stable_observable_id` = wrapper, NEVER changes across HMR (created once on first load)
- `mutable_observable_id` = inner, CHANGES on each HMR reload to point to new inner

## Solution/Approach
Emit a `mark-stable-next` event before creating the wrapper. Accumulator sets a flag on the stack track. Next `constructor-call-return` checks flag and sets `stable_observable_id`.

```typescript
// In trackedBehaviorSubject:
emit({ type: "mark-stable-next" })
const proxy = new BehaviorSubject(initialValue)

// In accumulator:
case "mark-stable-next":
  const track = state.stack.hmr_track.at(-1)
  if (track) track._nextIsStable = true
  break

case "constructor-call-return":
  if (track._nextIsStable) {
    track.stable_observable_id = event.id
    track._nextIsStable = false
  } else {
    track.mutable_observable_id = event.id
  }
```

## Tasks
- [ ] Add `mark-stable-next` event type to `00.types.ts`
- [ ] Remove `next_mutable_observable_id` field from `00.types.ts` (wrong approach)
- [ ] Handle `mark-stable-next` in accumulator (`03_scan-accumulator.ts`)
- [ ] Update `constructor-call-return` logic to check `_nextIsStable` flag
- [ ] Emit `mark-stable-next` in `trackedObservable` before creating wrapper
- [ ] Emit `mark-stable-next` in `trackedSubject` before creating wrapper
- [ ] Emit `mark-stable-next` in `trackedBehaviorSubject` before creating wrapper
- [ ] Remove direct state$ mutations from `0_runtime.ts`
- [ ] Run unit tests
- [ ] Run integration test

## Files to Modify
- `src/tracking/v2/00.types.ts` - Add event type, remove `next_mutable_observable_id`
- `src/tracking/v2/03_scan-accumulator.ts` - Handle new event, update constructor-call-return
- `src/tracking/v2/hmr/0_runtime.ts` - Remove direct mutations
- `src/tracking/v2/hmr/2_tracked-observable.ts` - Emit mark-stable-next
- `src/tracking/v2/hmr/3_tracked-subject.ts` - Emit mark-stable-next (both trackedSubject and trackedBehaviorSubject)

## Key Insights
1. `state$` should ONLY be mutated by the accumulator via events - runtime emits, accumulator mutates
2. Snapshot tests show correct results because of manual fixup in runtime, not because accumulator logic works
3. Event `observable` field in snapshots shows current state of object (with marker), not state at event time (without marker) - misleading
4. Stack lookups are O(n) and should be avoided - store-only lookups preferred
5. Tried storing track at `track-call` instead of `track-call-return` but broke tests (not all tracks produce observables)

## Open Questions
- Should `_nextIsStable` be a proper field on hmr_track type or just a runtime flag cast with `as any`?
- Do we need to handle nested track scopes where parent also has `_nextIsStable` set?

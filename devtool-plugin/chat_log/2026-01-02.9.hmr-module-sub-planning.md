# Session: hmr_module + __$.sub Planning

## Goal
Revalidate HMR architecture and plan `hmr_module` entity + `__$.sub` subscription wrapping for per-file cleanup during hot reload.

## Current State
- **Branch**: `feature/vite-instrumentation-v2`
- **Tests**: 69 passing, 3 skipped

## What's Already Implemented

### Stable Reference Layer
| Component | Purpose |
|-----------|---------|
| `trackedObservable(trackPath)` | Stable wrapper, re-subscribes to new inner on HMR |
| `trackedSubject(trackPath)` | Bi-sync proxy, forwards next/error/complete both directions |
| `trackedBehaviorSubject(trackPath)` | Same + `.value`/`.getValue()` forwarding |
| `__$` returns stable ref | Cold obs → trackedObservable, Subject → trackedSubject |

### Function Arg Hot-Swap
- `arg.fn_ref: WeakRef<Function>` stored at track time
- Lookup happens at **call time** via `state$.value.store.arg[id].fn_ref.deref()`
- New function automatically used without re-subscription
- This is the "like props but only funcs" mechanism

### Data Model (current)
```
hmr_track: {
  entity_type: "operator_fun" | "observable" | "pipe"
  entity_id: string           // FK → current entity (MUTABLE on HMR)
  parent_track_id?: string    // tree structure
  version: number             // bumps on HMR
  prev_entity_ids: string[]   // orphaned entities
  stable_ref?: WeakRef<Observable>  // trackedObservable wrapper
}

subscription: {
  observable_id: string       // FK → observable instance (NOT track!)
  parent_subscription_id?: string
  unsubscribed_at?: number
}
```

## The Gap

**Subscriptions attach to `observable_id` (concrete instance), not stable track identity.**

For tracked observables: fine - wrapper is stable, sub stays connected.

For raw observables or subs created in user modules:
1. Sub attaches to specific `observable_id`
2. HMR reloads file → old observable may be GC'd
3. No way to know "this sub belonged to file X"
4. No cleanup mechanism → dangling subscriptions

## Proposed: hmr_module + __$.sub

### New Entity: hmr_module
```ts
hmr_module: {
  id: string          // "file:///path/to/file.ts" or vite module id
  loaded_at: number   // timestamp of last HMR load
}
```

### Modified Entities
```ts
hmr_track: {
  // ...existing
  module_id?: string  // FK → hmr_module (which file created this track)
}

subscription: {
  // ...existing
  module_id?: string  // FK → hmr_module (which file created this sub)
}
```

### Vite Plugin Transformation Pattern

**Module wrapper:**
```ts
// Before (user code)
import { map } from 'rxjs'
const data$ = of(1,2,3).pipe(map(x => x*2))
data$.subscribe(console.log)

// After (transformed)
const __$ = _rxjs_debugger_module_start(import.meta.url)
import { map } from 'rxjs'
const data$ = __$("data$:3", () => of(1,2,3).pipe(map(x => x*2)))
__$.sub("sub:4", () => data$.subscribe(console.log))
__$.end()
```

**Key patterns:**
- `_rxjs_debugger_module_start(url)` returns scoped `__$` for this module
- `__$` is recursive for parser simplicity: `__$("outer", __$ => __$("inner", () => ...))`
- `__$.sub(key, factory)` wraps subscription creation
- `__$.end()` emits `hmr-module-call-return`, triggers dangling eval

### __$ Instance Shape
```ts
interface ModuleScope {
  // Track observable/pipe creation
  <T>(key: string, factory: () => T): T
  <T>(key: string, factory: (__$: ModuleScope) => T): T  // recursive

  // Track subscription creation
  sub(key: string, factory: () => Subscription): Subscription

  // Signal module evaluation complete
  end(): void

  // Internal
  module_id: string
  version: number
}
```

### HMR Events
```ts
| { type: "hmr-module-call"; id: string; url: string; version: number }
| { type: "hmr-module-call-return"; id: string }
```

### Cleanup Flow (on __$.end())

```
__$.end() called
      ↓
Emit hmr-module-call-return
      ↓
Compare tracks from prev version vs current version:
  - Same key re-executed → entity_id updated (already handled)
  - Key missing in new version → track orphaned, observable dangling
      ↓
Find all subs where:
  - observable_id points to orphaned observable
  - OR module_id = this module AND not re-created this version
      ↓
Unsubscribe dangling subs
```

### Why __$ IS the Module Scope

Stack-based tracking handles nested calls within execution.
Module scope is orthogonal - it's the file being evaluated.

By making `__$` itself carry module context:
- No global state to manage
- Each file gets isolated scope
- Recursive `__$` naturally inherits module_id
- `__$.end()` knows exactly which module finished

## Key Insights

1. **Tracked observables already handle sub stability** - no new mechanism needed for them
2. **`__$.sub` is for knowing WHO subscribed** - enables per-file cleanup
3. **`__$` IS the module scope** - no separate global, instance carries context
4. **Arg fn_ref swap already works** - lookup at call time, no changes needed
5. **Dangling eval on __$.end()** - compare prev vs current version, cancel orphaned subs

## Architecture: Module Lifecycle

```
_rxjs_debugger_module_start(url)
      ↓
Creates ModuleScope instance:
  - module_id = url
  - version = prev_version + 1 (or 1 if new)
  - tracks this version's keys in Set
      ↓
Emits hmr-module-call event
      ↓
Module code executes:
  - __$("key", ...) → stamps module_id on hmr_track
  - __$.sub("key", ...) → stamps module_id on subscription
  - Keys recorded in this-version Set
      ↓
__$.end()
      ↓
Emits hmr-module-call-return
      ↓
Diff: prev_version_keys - current_version_keys = orphaned_keys
      ↓
For orphaned tracks: mark observable dangling
For subs to dangling observables: unsubscribe
```

## Files to Modify

1. `src/tracking/v2/00.types.ts`
   - Add `hmr_module` entity type
   - Add `module_id` FK to `hmr_track` and `subscription`
   - Add `hmr-module-call` / `hmr-module-call-return` events

2. `src/tracking/v2/03_scan-accumulator.ts`
   - Handle `hmr-module-call` → create/update hmr_module, bump version
   - Handle `hmr-module-call-return` → diff keys, mark orphans, cancel dangling subs

3. `src/tracking/v2/hmr/0_runtime.ts`
   - Implement `_rxjs_debugger_module_start(url)` → returns ModuleScope
   - ModuleScope callable `__$(key, factory)` → existing logic + module_id stamp
   - ModuleScope `.sub(key, factory)` → wrap subscription + module_id stamp
   - ModuleScope `.end()` → emit hmr-module-call-return

4. `src/tracking/v2/hmr/4_module-scope.ts` (new)
   - ModuleScope class/factory
   - Key tracking per version

5. Vite plugin (separate repo/package)
   - Wrap module with `const __$ = _rxjs_debugger_module_start(import.meta.url)`
   - Transform observable creations → `__$("key", () => ...)`
   - Transform `.subscribe()` → `__$.sub("key", () => ...)`
   - Append `__$.end()`

## Tasks
- [x] Add hmr_module entity type to 00.types.ts
- [x] Add module_id FK to hmr_track and subscription types
- [x] Add hmr-module-call / hmr-module-call-return events
- [x] Implement _rxjs_debugger_module_start in runtime
- [x] Implement ModuleScope with __$(), .sub(), .end()
- [x] Add accumulator handlers for module events
- [x] Implement dangling detection on module-call-return
- [x] Implement auto-unsubscribe for dangling subs (marks in store)
- [x] Tests: 8 new tests for module lifecycle

## Implementation Notes

**Files modified:**
- `src/tracking/v2/00.types.ts` - Added `hmr_module` entity, `module_id` FK on `hmr_track` and `subscription`
- `src/tracking/v2/01.patch-observable.ts` - Added module events to UNTRACKED_EVENTS
- `src/tracking/v2/03_scan-accumulator.ts` - Handlers for module events + dangling detection
- `src/tracking/v2/hmr/4_module-scope.ts` - NEW: ModuleScope implementation

**Fixed:** Added `share()` to state$$ to prevent scan running multiple times per subscriber.

## Resolved Questions

1. **Key format**: `line:col:varName` from parser. Same module_id across all tracks in file. Nested tracks concatenate keys with `:` delimiter.
   ```ts
   __$("data$:3:1", __$ => __$("inner:5:3", () => ...))
   // produces track key: "data$:3:1:inner:5:3"
   ```

2. **Dynamic subscriptions (callbacks, setTimeout)**: Captured by closure of closest `__$`. The `__$` instance passed to factory carries module context, so async code using that closure stays associated.
   ```ts
   __$("outer:3", __$ => {
     setTimeout(() => {
       __$.sub("delayed:5", () => x$.subscribe(...))  // uses outer's module context
     }, 1000)
   })
   ```

3. **Orphaned observable GC**: Deferred - keep for now, revisit later.

4. **Recursive `__$` keys**: Concatenate with `:` delimiter. Inner inherits module_id from parent.
   ```ts
   __$("a:1", __$ => __$("b:2", () => ...))
   // key = "a:1:b:2", module_id = parent's module_id
   ```

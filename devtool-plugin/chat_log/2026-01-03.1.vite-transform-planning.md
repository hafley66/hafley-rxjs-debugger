# 2026-01-03 - vite-transform-planning

## Goal
Plan the Vite AST transform phase for user code instrumentation (Phase 5 of HMR MVP).

## Current State
- **Branch**: `feature/vite-instrumentation-v2`
- **Status**: Phases 1-3 complete, 85 tests passing, 3 skipped
- **Output**: Epic structure created at `chat_log/epics/hmr-mvp/`

## Problem/Context
Core HMR runtime is complete but only works with manually instrumented code. Need Vite plugin to auto-transform user code:
- Inject module lifecycle wrapper (`__$` start/end)
- Wrap observable declarations with `__$()`
- Wrap subscriptions with `__$.sub()`

## Solution/Approach

### Epic Structure Created

```
chat_log/epics/hmr-mvp/
├── board.md                       # Main board (6 phases)
├── tasks/                         # Gap cleanup tasks
│   ├── cleanup-dead-code.md       # Remove unused code
│   ├── fix-dangling-tests.md      # Fix skipped tests
│   ├── pipe-call-handler.md       # Empty handler
│   ├── error-propagation-tests.md # Missing tests
│   └── ast-pattern-catalog.md
└── vite-transform/                # Sub-epic
    ├── board.md                   # 5 phases (A-E)
    ├── ast-patterns.md            # Patterns to detect
    ├── file-detection.md          # Which files to transform
    ├── module-injection.md        # __$ lifecycle injection
    ├── key-generation.md          # Content hash strategy
    ├── observable-transforms.md   # __$() wrapping
    ├── subscription-transforms.md # __$.sub() wrapping
    └── transform-tests.md         # Test suite
```

### Vite Transform Phases

| Phase | Focus | Deliverable |
|-------|-------|-------------|
| A | Foundation | `file-detection.ts`, `ast-utils.ts` |
| B | Module wrapper | Inject `__$` start/end in v2.ts |
| C | Observable wrap | `__$("key", () => expr)` |
| D | Subscription wrap | `__$.sub("key", () => expr.subscribe())` |
| E | Tests | Comprehensive test suite |

### Key Design Decisions

1. **Key format**: `${varName}:${contentHash}`
   - Variable name for readability
   - Content hash (FNV-1a on normalized AST) for stability across line changes

2. **Detection patterns**:
   - RxJS creators: `of`, `from`, `interval`, `merge`, `combineLatest`, etc.
   - Subject constructors: `new Subject()`, `new BehaviorSubject(x)`
   - Pipe chains: `source$.pipe(...)`
   - Subscribe calls: `obs$.subscribe(...)`

3. **Skip rules**:
   - Already wrapped (has `__$`)
   - Inside `__$` factory (child scope handles)
   - Test files (configurable)
   - `.d.ts` files
   - `node_modules` (except rxjs, handled separately)

4. **Edge cases deferred**:
   - Destructuring: `const { data$ } = obj`
   - Conditionals: `const x$ = flag ? a$ : b$`
   - Computed properties: `obj[key] = of(1)`

### Transform Example

**Before**:
```typescript
import { map } from 'rxjs'
const data$ = of(1, 2, 3)
const mapped$ = data$.pipe(map(x => x * 2))
mapped$.subscribe(console.log)
```

**After**:
```typescript
import { _rxjs_debugger_module_start } from "rxjs-debugger/hmr"
const __$ = _rxjs_debugger_module_start(import.meta.url)
import { map } from 'rxjs'
const data$ = __$("data$:a1b2c3", () => of(1, 2, 3))
const mapped$ = __$("mapped$:d4e5f6", () => data$.pipe(map(x => x * 2)))
__$.sub("sub:g7h8i9", () => mapped$.subscribe(console.log))
__$.end()
```

## Gaps Identified (Skipped for Now)

| Gap | Risk | Status |
|-----|------|--------|
| Dead code (suppressSend$, decorateHigherMap, rel[]) | Low | Deferred |
| Skipped getDanglingSubscriptions tests (3) | Medium | Deferred |
| Empty pipe-call handler | Low | Deferred |
| No error propagation tests | Medium | Deferred |
| is_sync flag never set | Low | Deferred |
| index: 0 always | Low | Deferred |

## Files to Create

- `src/vite-plugin/user-transform.ts` - Main transform logic
- `src/vite-plugin/ast-utils.ts` - Detection helpers
- `src/vite-plugin/key-generator.ts` - Key generation
- `src/vite-plugin/__tests__/user-transform.test.ts`

## Files to Modify

- `src/vite-plugin/v2.ts` - Add user code transform hook

## Key Insights

1. **oxc-parser already in use** - v2.ts uses it for RxJS lib transforms, reuse for user code
2. **MagicString for transforms** - Preserves source maps, already in use
3. **Content hash critical** - Line numbers change during dev, need stable keys
4. **Skip detection important** - Don't double-wrap, respect factory boundaries

## Open Questions

- Should test files be transformed by default? (Current: skip by default)
- Should we support ReplaySubject/AsyncSubject? (Not implemented in runtime yet)
- How to handle dynamic imports? (Deferred)

## Next Steps

1. Implement Phase A: File detection + AST pattern utilities
2. Implement Phase B: Module wrapper injection
3. Implement Phase C: Observable declaration wrapping
4. Implement Phase D: Subscription wrapping
5. Implement Phase E: Comprehensive test suite

# Plan: track-update System for RxJS HMR

## Goal
Implement MVP track-update system: detect HMR re-execution, swap sources in trackedObservable, patch Subjects for bidirectional HMR support.

## Key Insight
The arg-crawler already looks up `fn_ref` at call time (02_arg-crawler.ts:44-46), enabling hot-swap of function references without re-subscription.

## Decision Tree (MVP)
```
Code Change (HMR) → __$(location) re-executes
                          ↓
              Does hmr_track[location] exist?
                    /           \
                  NO            YES
                  ↓              ↓
              Normal       entity_id different?
               flow              ↓
                               YES → Emit track-update
                                     trackedObservable swaps source
```

For MVP, we skip hash comparison and always emit track-update when entity_id changes.
Hash optimization (fn-only hot swap) deferred to Phase N+1.

## Implementation Phases

### Phase 1: Emit track-update on Re-execution
**File:** `src/tracking/v2/03_scan-accumulator.ts`

Modify `track-call-return` handler:
```typescript
case "track-call-return": {
  const entity = state.stack.hmr_track.pop()
  if (!entity) break

  const existing = state.store.hmr_track[entity.id]
  if (existing && existing.entity_id !== entity.entity_id) {
    // HMR re-execution - emit track-update
    existing.prev_entity_ids.push(existing.entity_id)
    existing.entity_id = entity.entity_id
    existing.version += 1
    // trackedObservable watchers will see this change
  } else if (!existing) {
    state.store.hmr_track[entity.id] = entity
  }
  break
}
```

### Phase 2: Silent Swap in trackedObservable
**File:** `src/tracking/v2/hmr/2_tracked-observable.ts`

Track swapping state, suppress complete only during swap:
```typescript
let isSwapping = false

const connectToSource = (entityId: string) => {
  if (entityId === lastEntityId) return
  isSwapping = true
  innerSub?.unsubscribe()
  // ... subscribe to new source ...
  isSwapping = false
}

// In subscriber:
complete: () => {
  if (!isSwapping) subscriber.complete()
}
```

### Phase 3: Subject Instance Patching
**File:** `src/tracking/v2/hmr/0_runtime.ts`

When `__$` returns a Subject/BehaviorSubject, patch the instance:
```typescript
if (result instanceof Subject) {
  const trackId = location
  const originalNext = result.next.bind(result)
  result.next = (value) => {
    const currentId = state$.value.store.hmr_track[trackId]?.entity_id
    const current = state$.value.store.observable[currentId]?.obs_ref?.deref()
    ;(current ?? result).next(value)
  }
  // same for error/complete
}
```

Old references still work - `.next()` forwards to current entity.

## Edge Cases to Handle

| Case | Behavior |
|------|----------|
| Subject as source+sink | Instance patching forwards .next() to current entity |
| BehaviorSubject replay | New value replays on swap (document) |
| Nested trackedObservable | All instances update together (correct) |
| Loops with observables | User must use stable IDs (like React keys) |

## Files to Modify/Create

1. **MODIFY** `src/tracking/v2/03_scan-accumulator.ts` - track-call-return: always emit track-update on entity_id change (MVP)
2. **MODIFY** `src/tracking/v2/hmr/2_tracked-observable.ts` - suppress complete during swap only
3. **MODIFY** `src/tracking/v2/hmr/0_runtime.ts` - Subject instance patching for .next()/.error()/.complete()
4. **CREATE** `src/tracking/v2/hmr/2_tracked-observable.test.ts` - add tests for swap scenarios

## Decisions Made

| Question | Decision |
|----------|----------|
| Hash comparison? | **Defer** - always emit track-update for MVP, add hash optimization later |
| Complete propagation? | **Suppress during swap only** - track swapping state, forward otherwise |
| Subject bidirectional? | **Instance patching** - patch .next/.error/.complete on Subject instances in __$ |

## Future Optimization (Phase N+1)

- Add structural hash comparison to detect fn-only changes
- Skip track-update when hash matches, just swap fn_refs
- This enables true hot-swap without resubscription

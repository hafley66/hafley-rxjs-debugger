# React Refresh ↔ RxJS HMR Analysis

## React Refresh Model

1. **Component function gets replaced** - new code, same identity
2. **Fiber tree stays stable** - DOM structure persists
3. **useEffect cleanup → new effect** - old effect cleaned up, new runs
4. **Identity by position** - hooks identified by call order

Key: React doesn't give "stable functions" - it keeps the *tree structure* stable and re-runs effects with new functions.

## Mapping to RxJS

| React | RxJS |
|-------|------|
| Component function | Observable factory |
| Fiber tree | Subscription tree |
| useEffect | subscribe() |
| useEffect cleanup | unsubscribe() |
| Context | Shared observable |
| Context.Provider value | Subject.next() |

## How React Handles Cross-Module Subscriptions

"Module B subscribes to Module A's export" scenario:

```jsx
// Module A
export const MyContext = createContext(defaultValue)

// Module B (not reloaded)
function Consumer() {
  const value = useContext(MyContext)  // subscribes to context
}
```

On HMR of Module A:
- Context object reference changes
- React Refresh has "families" - old/new with same signature = same identity
- Subscriptions (useContext) re-render with new value automatically

## RxJS Analog: trackedObservable

`trackedObservable` IS the React Refresh analog for observables:

```ts
// Module A
const inner$ = __$("obs", () => interval(1000))
export const obs$ = trackedObservable("a:obs")  // stable wrapper

// Module B (not reloaded)
obs$.subscribe(handler)  // subscribed to wrapper, not inner
```

On HMR of A:
1. New inner$ created, hmr_track.entity_id updates
2. trackedObservable detects change, re-subscribes to new inner
3. Module B's subscription seamlessly receives from new source

## Architecture Summary

| Concern | Solution |
|---------|----------|
| Stable observable reference | `trackedObservable` wraps inner, re-subscribes on swap |
| Cleanup subscriptions in reloaded module | `hmr_subscription` mark-and-sweep |
| Stable Subject (hot/multicast) | Bi-sync pattern (deferred) |

## Key Insight

`__$` should automatically return `trackedObservable` wrapper, not raw result. This makes HMR seamless for exports - external subscribers stay connected through the swap.

## No `stable_sub` Needed

Subscriptions to `trackedObservable` persist automatically because:
- The wrapper observable is stable
- Only the inner source changes
- Wrapper re-subscribes internally, external subscription unaffected

# 2026-01-04 - scan-accumulator-cleanup

## Goal
Clean up the scan accumulator architecture so hmr_track logic is properly isolated in `track-call-return`, not scattered across multiple event handlers.

## Current State
- Branch: `feature/vite-instrumentation-v2`
- All 131 unit tests pass
- Integration test (`hmr-integration/`) is untracked and needs separate investigation
- Architectural cleanup complete

## Problem/Context

### The Original Issue
Generic observable lifecycle events were doing HMR track bookkeeping:
- `constructor-call-return` was inferring mutable/stable IDs via TRACKED_MARKER timing
- `factory-call-return` and `pipe-call-return` were setting `track.mutable_observable_id`
- Runtime was doing manual `state$` mutations to fix broken accumulator logic

### Why It Was Broken
When `trackedBehaviorSubject` creates its proxy:
```typescript
const proxy = new BehaviorSubject(initialValue)  // constructor-call-return fires HERE
;(proxy as any)[TRACKED_MARKER] = true            // marker set AFTER
```
The TRACKED_MARKER check failed because marker wasn't set yet.

## Solution/Approach

**Principle**: Runtime knows the IDs, emit them directly in `track-call-return`. Accumulator receives, not infers.

### Changes Made

1. **Event types** (`00.types.ts`):
   - `track-call-return` now carries `mutable_observable_id` and `stable_observable_id`
   - Removed `next_mutable_observable_id` field from hmr_track type

2. **Accumulator** (`03_scan-accumulator.ts`):
   - Removed hmr_track logic from `constructor-call-return`, `factory-call-return`, `pipe-call-return`
   - `track-call-return` sets IDs from event directly
   - Removed TRACKED_MARKER import (no longer needed)

3. **Runtime** (`0_runtime.ts`):
   - Emits IDs in `track-call-return` event
   - Removed all manual `state$` mutations
   - Passes `mutableId` to wrapper constructors

4. **Wrappers** (`2_tracked-observable.ts`, `3_tracked-subject.ts`):
   - Accept `initialMutableId` parameter
   - Check if observable is in store before connecting (handles async bootstrap)

5. **Module scope** (`4_module-scope.ts`):
   - Enables tracking via `isEnabled$.next(true)` at module start

## Tasks
- [x] Add mutable_observable_id and stable_observable_id to track-call-return event
- [x] Remove hmr_track logic from constructor-call-return
- [x] Remove hmr_track logic from factory-call-return
- [x] Remove hmr_track logic from pipe-call-return
- [x] Update track-call-return accumulator to set IDs from event
- [x] Update runtime to emit IDs and remove manual mutations
- [x] Pass mutableId to wrapper constructors
- [x] Run unit tests (131 pass)
- [ ] Investigate integration test (separate concern - browser timing issue)

## Files Modified
- `src/tracking/v2/00.types.ts` - Event types, removed next_mutable_observable_id
- `src/tracking/v2/03_scan-accumulator.ts` - Removed scattered hmr_track logic
- `src/tracking/v2/hmr/0_runtime.ts` - Emit IDs, removed state$ mutations
- `src/tracking/v2/hmr/2_tracked-observable.ts` - Accept initialMutableId
- `src/tracking/v2/hmr/3_tracked-subject.ts` - Accept initialMutableId
- `src/tracking/v2/hmr/4_module-scope.ts` - Enable isEnabled$ at start

## Key Insights
1. **Source-level patching**: ALL Observable constructors are patched at Vite transform level, so piped observables DO get constructor-call-return events
2. **Async bootstrap**: Events are buffered until bootstrap runs (queueMicrotask), so wrappers may be created before store is populated
3. **Clean separation**: Each event handler now has single responsibility - no cross-cutting hmr_track concerns

## Open Questions
- Integration test fails with empty values - likely browser-specific async timing issue with bootstrap
- Test was never committed (untracked), may need separate debugging session

# 2026-01-01 Vite Plugin Internal Flag

## Goal
Add `internal` flag to Observable records so UI can auto-collapse internal rxjs plumbing trees.

## Current State
- **Branch**: `feature/vite-instrumentation-v2`
- **Commit**: `515dfea feat: inline source transformation for operators and creation functions`
- **Inline source transformation**: Working for operators and creation functions
- **All tests passing**: vitest and browser tests

## What's Working
- Vite plugin transforms rxjs source files at build time
- Operators wrapped with `decorateOperatorFun`
- Creation functions wrapped with `decorateCreate`
- Handles esm5, esm, and TypeScript source files
- Handles alias exports (e.g., `onErrorResumeNext = onErrorResumeNextWith`)

## Problem/Context
Currently skipping internal files like `innerFrom`. Want to track them but mark as `internal: true` so:
1. UI can auto-collapse internal trees
2. User sees their code, not rxjs plumbing
3. Optional "show internals" toggle

## Solution/Approach
1. Add `internal` option to decorators: `decorateCreate(fn, "innerFrom", { internal: true })`
2. Decorator sets context flag before calling original function
3. Observable constructor sees flag â†’ emits `constructor-call-return` with `internal: true`
4. Store saves `internal` on Observable record (not on every event - relational design)
5. UI checks `observable.internal` to decide collapse behavior

```ts
// In decorateCreate
const decorated = (...args) => {
  _internalContext = options?.internal ?? false
  const out = fun(...args)
  _internalContext = false
  return out
}

// In constructor patch
emit({ type: "constructor-call-return", id, observable: this, internal: _internalContext })
```

## Tasks
- [ ] Add `internal` option to `decorateCreate` signature
- [ ] Add `internal` option to `decorateOperatorFun` signature
- [ ] Add `_internalContext` flag and logic in decorators
- [ ] Update constructor patch to read `_internalContext` and emit with `internal`
- [ ] Add `internal?: boolean` to `ObservableRef` type in `00.types.ts`
- [ ] Stop skipping `innerFrom` files, instead decorate with `internal: true`
- [ ] Update vite plugin to pass `internal: true` for known internal files
- [ ] Update tests/snapshots

## Files to Modify
- `src/tracking/v2/01.patch-observable.ts` - decorators and constructor patch
- `src/tracking/v2/00.types.ts` - add `internal` to ObservableRef
- `src/vite-plugin/v2.ts` - pass `internal` flag based on file path

## Key Insights
- Only Observable record needs `internal` flag, not every event (relational design)
- Internal files: `innerFrom`, `fromArrayLike`, `fromPromise`, etc.
- User-facing: anything re-exported from `rxjs` or `rxjs/operators` entry points

## Open Questions
1. Exact list of files to mark as internal?
2. Should `OperatorSubscriber` also be tracked with internal flag?
3. UI implementation for collapse/expand internals?

trust me im cracking away like that af, im a react dev and see the frp family dna between reacrt and rxjs, rxjs is react bc components/props are creator/factory observable functions, react and its hooks are auto flattened combineLatest + taps, and tap is the FRP escape hatch and discouraged, yet useEffect is slobbed on. react is frp with auto flattened signals with constant ref/sub (useState without condtional usage). to me they are the same, so i can design things similar to react trees by really thinking and breaking down the rxjs relational model as a debug tool. then u salt with a vite plugin that does its best at auto tracking/parsing any calls to rxjs stuff, with a "__track(() => code that was there before)". So i can store special parse time info into the relational tables i have and can join to them in the ui code. then if certain conditions apply (i have notion of pipe tree, if the pipe tree of a root track instance is same structure as the previous one (during hmr, and like react hooks), we try to preserve the subscriptions by splicing/switchMapping to the new obs value from hmr. by having track with cache busting tagging somehow, we can preserve obs state/identity across reloads. Dynamic pipes during sub time (inside literal new Obs, higher maps, etc.) if hooks and pipes are cousins, or jsx tree is cousin to pipes im not sure but i know a tree structure when i see it. in react, the 2 observables are props/jsx and hooks, whereas in rxjs there is observables and...more observables


# HMR Tracking - Per-Subscription Tracking

## Goal
Build HMR (Hot Module Replacement) for RxJS that keeps subscriptions alive while swapping source observables when code changes. Mirror React's HMR pattern.

## Current State
- Branch: `feature/vite-instrumentation-v2`
- Core HMR types and events added (`track-call`, `track-call-return`, `track-update`)
- `trackedObservable` implemented - watches `hmr_track.entity_id` and switches source
- `__$` runtime wrapper for tracking observable creation
- `obs_ref` WeakRef on observable entities for id → live observable lookup
- `fn_ref` WeakRef on arg entities for function swapping
- `state$$` shared state stream from accumulator

## Problem/Context
Infinite loop when `trackedObservable` subscribes to `state$$`:
1. `trackedObservable` watches `state$$` for entity_id changes
2. When entity_id changes, it subscribes to the source observable
3. That subscribe emits events (subscribe-call, send-call)
4. Events go to accumulator → `state$$` emits
5. `trackedObservable` callback fires again → loop

The global `track(false)` flag is too coarse - it disables ALL tracking, but we need:
- Observable/pipe creation: global tracking is fine
- Operator fun calls: can't track per-observable (1:many relationship)
- **Send events (next/error/complete): should only emit for "tracked" subscriptions**

## Solution/Approach
**Per-subscription tracking for sends:**
1. Maintain a `Set<string>` of tracked subscription IDs
2. In patched `subscribe()`: if `isTracking()` is true, add subscription ID to the set
3. In `wrappedObserver.next/error/complete`: only emit send events if subscription_id is in the tracked set
4. Internal subscriptions (created with `track(false)`) won't be in the set, so their sends won't emit

This isolates send events to user-created subscriptions, breaking the recursive loop.

## Tasks
- [ ] Add `trackedSubscriptions = new Set<string>()` to 01_helpers.ts
- [ ] In patched subscribe: `if (isTracking()) trackedSubscriptions.add(subscription_id)`
- [ ] In wrappedObserver.next/error/complete: only emit if `trackedSubscriptions.has(subscription_id)`
- [ ] Clean up subscription from set on unsubscribe
- [ ] Get trackedObservable tests passing
- [ ] Remove debug console.logs added during debugging

## Files to Modify
- `src/tracking/v2/01_helpers.ts` - add trackedSubscriptions Set
- `src/tracking/v2/01.patch-observable.ts` - use set in patched subscribe
- `src/tracking/v2/hmr/2_tracked-observable.ts` - clean up debug logs
- `src/tracking/v2/00.types.ts` - clean up debug logs

## Key Insights
- `track()` now returns an undo function: `const undo = track(false); ...; undo()`
- Global tracking is inherently problematic for observables that observe state
- The real issue is send events creating feedback loops, not subscribe events
- `shareReplay` and other RxJS operators create internal subscriptions that also cause issues
- `state$` (EasierBS) creation must be wrapped in `track(false)` to avoid tracking internal BehaviorSubject

## Open Questions
- Should we also track subscriptions in state for debugging/visualization?
- How to handle nested subscriptions (parent tracked, child not)?
- Memory management for trackedSubscriptions Set - need cleanup on unsubscribe

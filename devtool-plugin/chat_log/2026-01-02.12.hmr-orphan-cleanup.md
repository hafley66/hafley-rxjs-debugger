# Session: HMR Orphan Cleanup

## Goal
Implement proper cleanup for orphaned tracked observables when HMR module reloads without re-creating certain tracks.

## Current State
- **Branch**: `feature/vite-instrumentation-v2`
- **Tests**: 83 passing, 3 skipped
- **Commit**: `91e7a5f feat: add HMR module lifecycle with orphan cleanup`

## Problem/Context
- trackedSubject created persistent `state$$` watcher subscriptions that never cleaned up
- When a module reloads and doesn't re-create a track, that track becomes "orphaned"
- Orphaned tracks leaked memory: watcher subs stayed alive, entries stayed in store
- Previous orphan detection filtered by `module_id` only, but orphaned tracks still had that module_id

## Solution/Approach

### 1. Track version stamping
- Added `module_version` field to `hmr_track`
- On `track-call-return`, stamp track with current module version
- Orphan = track with `module_version !== module.version` after module-end

### 2. Self-subscribe teardown pattern
- trackedSubject/trackedBehaviorSubject self-subscribe to proxy
- On `complete` callback: unsubscribe `watcherSub` and `innerSub`
- Subject is multicast so extra subscriber is fine

### 3. Orphan cleanup in accumulator
- On `hmr-module-call-return`: filter by `module_version === module.version`
- For orphaned keys: `wrapper.complete()` triggers teardown, then `delete` from store

## Key Code Changes

**3_tracked-subject.ts**:
```ts
__withNoTrack(() =>
  proxy.subscribe({
    complete: () => {
      innerSub?.unsubscribe()
      watcherSub.unsubscribe()
    },
  }),
)
```

**03_scan-accumulator.ts**:
```ts
// track-call-return: stamp module_version
existing.module_version = currentModule?.version

// hmr-module-call-return: filter by version
.filter(t => t.module_id === module.id && t.module_version === module.version)

// cleanup orphans
const wrapper = track.stable_ref?.deref()
if (wrapper instanceof Subject) wrapper.complete()
delete state.store.hmr_track[key]
```

## Tasks
- [x] Add `module_version` to hmr_track type
- [x] Stamp `module_version` on track-call-return
- [x] Filter orphans by `module_version` match
- [x] Self-subscribe teardown in trackedSubject
- [x] Complete wrapper and delete track for orphans
- [x] Add test validating orphan cleanup

## Files Modified
- `src/tracking/v2/00.types.ts` - added `module_version` field
- `src/tracking/v2/03_scan-accumulator.ts` - orphan detection and cleanup logic
- `src/tracking/v2/hmr/3_tracked-subject.ts` - self-subscribe teardown pattern
- `src/tracking/v2/hmr/4_module-scope.test.ts` - orphan cleanup test

## Key Insights
1. **Subject.add() doesn't exist in RxJS 7+** - Subject no longer extends Subscription
2. **Self-subscribe is the RxJS-native pattern** - multicast means extra subscriber is fine
3. **module_id alone insufficient for orphan detection** - need version stamping to know if touched this reload
4. **complete() triggers teardown cascade** - one call cleans up watcher and inner subs

## Open Questions
None - orphan cleanup is complete and tested.

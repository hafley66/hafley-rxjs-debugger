# Plan: __$ Returns trackedObservable + Dangling Detection

## Summary
1. Make `__$` return `trackedObservable(path)` wrapper instead of raw factory result
2. Store `stable_ref: WeakRef<Observable>` on `hmr_track` entity (NO new Maps)
3. Dynamic observables (created during subscribe) get subscription context in path

## Storage

**stable_ref on hmr_track** (not a separate Map):
```ts
hmr_track: {
  // ...existing fields
  stable_ref?: WeakRef<Observable<any>>  // the trackedObservable wrapper
}
```

## Dynamic Observable Naming

Observables created during subscribe get subscription context prepended:
```
$ref[outerObsId]:subscription[subId]:selector
```

Example: switchMap inner observable might be:
```
$ref[interval_1]:subscription[sub_5]:inner
```

This gives unique identity based on subscription tree position.

## The Insight

`trackedObservable` already handles stable references:
- Watches `hmr_track[path].entity_id` for changes
- Re-subscribes to new inner observable on HMR
- External subscriptions seamlessly receive from new source

Dangling subscriptions = subscriptions to observables no longer tracked:
```ts
const liveObsIds = new Set(Object.values(store.hmr_track).map(t => t.entity_id))
const dangling = Object.values(store.subscription).filter(s =>
  !liveObsIds.has(s.observable_id) && !s.unsubscribed_at
)
```

## Files to Modify

1. `src/tracking/v2/00.types.ts` - Add stable_ref to hmr_track type
2. `src/tracking/v2/hmr/0_runtime.ts` - Make __$ return trackedObservable, use store.hmr_track.stable_ref
3. `src/tracking/v2/hmr/1_queries.ts` - Add dangling subscription query
4. Tests

## Implementation Order

1. Add stable_ref to hmr_track type
2. Modify __$ to check/set hmr_track.stable_ref instead of Map
3. Handle dynamic observable naming (subscription context prefix)
4. Add query for dangling subscriptions
5. Tests

## Test Scenarios

### __$ Returns trackedObservable
- `__$("obs", () => new Subject())` returns trackedObservable wrapper, not raw Subject
- External subscriber receives values after HMR swap (seamless reconnection)
- Same reference returned on subsequent __$ calls with same path
- stable_ref stored on hmr_track entity in store (not separate Map)

### Dynamic Observable Naming
- Observable created during subscribe gets subscription context in path
- Path format: `$ref[obsId]:subscription[subId]:selector`

### Dangling Detection
- Subscription to orphaned observable (not in any hmr_track.entity_id) detected as dangling
- Subscription to live observable (in hmr_track.entity_id) not detected as dangling
- Already unsubscribed subscriptions excluded from dangling query

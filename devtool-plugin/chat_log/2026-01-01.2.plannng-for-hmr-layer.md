# RxJS HMR Instrumentation - Agent Implementation Guide

## Overview

Building an RxJS Hot Module Replacement system that mirrors React's HMR pattern. Core principle: **keep subscriptions alive, swap function args on code change, next emission flows through new code naturally**.

---

## Core Insight: React HMR Parallel

```
React                           RxJS
─────                           ────
Component instance (mounted)  = Subscription (active)
Props                         = Operator args
Re-render                     = Next emission
Component ref (stable)        = Operator ref (stable)
Hook signature                = Structural hash (op types + order)
```

React doesn't re-mount on HMR. Component stays mounted, just re-runs body with new code. State survives because it's external.

**RxJS equivalent:** Don't unsub/resub. Keep subscription alive. Swap arg references in tracked operators. Next emission flows through new args naturally.

---

## Existing Relational Model

The codebase already has event capture producing these entities:

```typescript
type Entities = {
  observable: { id, name, created_at, created_at_end }
  operator_fun: { id, name, created_at, created_at_end }
  operator: { id, operator_fun_id, pipe_id, index, source_observable_id, target_observable_id }
  pipe: { id, parent_observable_id, observable_id }
  subscription: { id, observable_id, parent_subscription_id, is_sync, unsubscribed_at? }
  arg: { id, owner_id, path, is_function, value?, fn_source?, observable_id? }
  arg_call: { id, arg_id, observable_id?, subscription_id?, input_values? }
  send: { id, observable_id, subscription_id, type, value? }
}
```

Events flow through `_observableEvents$` subject, accumulated into `state$.value.store`.

---

## Key Design Decision: Parse-Time vs Runtime Tracking

### The Problem

We need stable identity for operators that survives HMR. Runtime IDs are ephemeral (generated fresh each execution). We need source-location-based keys.

### Option A: Runtime Only (Stack Traces + Counter)

```typescript
// Grab location from stack at creation time
function wrapCreation(name, fn) {
  return (...args) => {
    const stack = new Error().stack
    const location = parseLocation(stack) // 'foo.ts:42'
    const trackKey = `${location}:${counter++}:${name}`
    // ...
  }
}
```

**Pros:**
- Works now, no build tooling
- Bundler agnostic

**Cons:**
- Stack parsing fragile (minification, browsers differ)
- Counter breaks if execution order changes
- Can't distinguish "code moved" vs "code changed"
- No static analysis possible
- Can't know what changed BEFORE code runs

### Option B: Parse-Time (AST Transform)

```typescript
// Vite plugin transforms source:
of(1).pipe(map(x => x * 2))

// Into:
__$('foo.ts:10', $ => 
  $('of', of(1)).pipe(
    $('map', map(x => x * 2))
  )
)
```

**Pros:**
- Identity is SOURCE position, not execution position
- Can diff AST before running → know what changed
- Can detect: "operator moved from line 42 to 67" (same hash, different location)
- Enables devtools: "this subscription uses OLD code from 2 HMRs ago"
- Zero runtime cost for identity resolution
- Source map integration for free

**Cons:**
- Every syntactic pattern needs handling
- Dynamic code (eval, factories) opaque
- Bundler coupling

### Decision: Parse-Time First

Parse-time gives superior capabilities. Runtime can be fallback for edge cases (dynamic factory functions, etc).

**Key future unlock with parse-time:**

```typescript
// At HMR time, BEFORE code runs:
const diff = compareAST(oldModule, newModule)

diff = {
  unchanged: ['foo.ts:10:map', 'foo.ts:15:filter'],
  argsChanged: ['foo.ts:20:scan'],        // same structure, different fn body
  moved: [{ from: 'foo.ts:25', to: 'foo.ts:30', key: 'switchMap' }],
  added: ['foo.ts:35:tap'],
  removed: ['foo.ts:40:debounce']
}

// Now you KNOW ahead of execution:
// - argsChanged → swap args, keep subs
// - added/removed → teardown affected branches
// - moved → no-op if structure same
```

Runtime can't do this - you only discover structure AS it executes.

---

## The `__$` Tracking Primitive

### Why Callback Shape

JavaScript lacks Python decorators. We need functional scope to:
1. Buffer all events during creation
2. Pass parent context down for nesting
3. Know when scope ends (callback returns)
4. Correlate buffered events to track ID

### Signature

```typescript
__$(location: string, fn: ($: TrackContext) => T): T
```

### Usage Patterns

```typescript
// Simple observable
const foo$ = __$('foo.ts:5:of', $ => 
  $('of', of(1, 2, 3))
)

// Pipe chain
const bar$ = __$('foo.ts:9:pipe', $ => 
  foo$.pipe(
    $('map', map(x => x * 2)),
    $('filter', filter(x => x > 0)),
  )
)

// Nested (switchMap with inner observable)
const baz$ = __$('foo.ts:16:pipe', $ => 
  bar$.pipe(
    $('switchMap', switchMap(x => 
      __$('foo.ts:18:inner', $$ => 
        $$('of', of(x, x + 1))
      )
    ))
  )
)
```

### Implementation Sketch

```typescript
type TrackContext = (name: string, value: any) => any

function __$<T>(location: string, fn: ($: TrackContext) => T): T {
  const trackId = location
  const parentTrackId = currentTrackScope // from context/global
  
  // Buffer events during this scope
  const eventBuffer: ObservableEvent[] = []
  const unsub = _observableEvents$.subscribe(e => eventBuffer.push(e))
  
  // Create child tracker bound to this parent
  const $: TrackContext = (name, value) => {
    const childId = `${trackId}:${name}`
    registerTrack(childId, trackId, value)
    return value
  }
  
  // Execute with context
  const prevScope = currentTrackScope
  currentTrackScope = trackId
  const result = fn($)
  currentTrackScope = prevScope
  
  // Flush buffer, correlate events to this track
  unsub.unsubscribe()
  processBufferedEvents(trackId, parentTrackId, eventBuffer, result)
  
  return result
}
```

### Line Numbers in Pipe

For pipe operators, we may want line-level granularity:

```typescript
__$('foo.ts:9:pipe', $ => 
  foo$.pipe(
    $('10:map', map(x => x * 2)),      // line 10
    $('11:filter', filter(x => x > 0)), // line 11
    $('12:scan', scan((a, x) => a + x, 0)), // line 12
  )
)
```

This makes track IDs like `foo.ts:9:pipe:10:map` - fully identifies the operator in source.

---

## New Schema: `hmr_track` Table

```typescript
hmr_track: {
  id: string                // stable source location: 'foo.ts:42:pipe:10:map'
  entity_type: 'operator_fun' | 'observable' | 'pipe'
  entity_id: string         // FK → current entity (MUTABLE on HMR)
  parent_track_id?: string  // tree structure for nesting
  index: number             // position in parent scope
  version: number           // bumps on HMR
  prev_entity_ids: string[] // orphaned entities, awaiting GC
}
```

### Why This Design

- `id` is stable across HMR (source location from parse time)
- `entity_id` is what gets swapped on HMR (points to current operator_fun/observable)
- `parent_track_id` gives tree structure - structural hash is DERIVED from this, not stored
- `prev_entity_ids` enables soft delete + sweep for cleanup when safe

### Structural Hash is a Query

Do NOT store structural hash. Derive it:

```typescript
function deriveStructuralPath(store: Store, trackId: string): string {
  const track = store.hmr_track[trackId]
  if (!track) return ''
  
  const entity = store[track.entity_type][track.entity_id]
  const name = entity?.name ?? 'unknown'
  const segment = `${track.index}:${name}`
  
  if (!track.parent_track_id) return segment
  
  return deriveStructuralPath(store, track.parent_track_id) + '|' + segment
}

// Example: "0:pipe|0:map|1:filter|2:switchMap"
```

This lets you detect structural changes by comparing derived paths.

---

## HMR Mechanism

### Write Sequence

```
T0: Initial module execution
────────────────────────────
INSERT operator_fun { id: '13', name: 'map' }
INSERT arg { id: '14', owner_id: '13', path: '$args.0', fn_source: 'x => x * 2' }
INSERT hmr_track { id: 'foo.ts:10:map', entity_type: 'operator_fun', entity_id: '13', version: 1 }

T1: Subscription created
────────────────────────
INSERT subscription { id: '31', observable_id: '28' }  // ACTIVE

T2: HMR triggers (user edited map function)
───────────────────────────────────────────
INSERT operator_fun { id: '99', name: 'map' }  // NEW
INSERT arg { id: '100', owner_id: '99', path: '$args.0', fn_source: 'x => x * 3' }  // NEW CODE
UPDATE hmr_track SET entity_id = '99', version = 2, prev_entity_ids = ['13'] WHERE id = 'foo.ts:10:map'

// Note: NO new subscription, NO unsub/resub
// Subscription '31' stays active
```

### Swap vs Teardown Decision

```typescript
function handleHMR(trackId: string, newEntityId: string) {
  const store = state$.value.store
  const track = store.hmr_track[trackId]
  
  const oldPath = deriveStructuralPath(store, trackId)
  
  // Temporarily set new entity to compute new path
  const newPath = deriveStructuralPathWith(store, trackId, newEntityId)
  
  if (oldPath !== newPath) {
    // Structure changed → teardown affected subscriptions, rebuild
    teardownTrack(trackId)
  } else {
    // Structure same → swap entity_id, keep subscriptions alive
    swapTrack(trackId, newEntityId)
  }
}

function swapTrack(trackId: string, newEntityId: string) {
  const track = state$.value.store.hmr_track[trackId]
  
  updateStore('hmr_track', trackId, {
    entity_id: newEntityId,
    version: track.version + 1,
    prev_entity_ids: [...track.prev_entity_ids, track.entity_id]  // orphan old
  })
}
```

### Runtime Indirection

For swap to work, operators can't close over arg functions directly. They must resolve at emission time:

```typescript
function createHotSwappableOperator(trackId: string, createOp: (...args) => OperatorFunction) {
  return (source: Observable<any>) => {
    return new Observable(subscriber => {
      return source.subscribe({
        next: (value) => {
          // Resolve CURRENT args at emission time
          const track = state$.value.store.hmr_track[trackId]
          const args = getArgsFor(state$.value.store, track.entity_id)
          const fn = args.find(a => a.path === '$args.0')?.fn
          
          // Apply with current function
          subscriber.next(fn ? fn(value) : value)
        },
        error: (e) => subscriber.error(e),
        complete: () => subscriber.complete()
      })
    })
  }
}
```

---

## Lifecycle Management

### Two Lifecycles

| Lifecycle | Trigger | Action |
|-----------|---------|--------|
| Runtime | subscription completes/unsubs | cascade delete: sends, child subs, arg_calls |
| HMR | code replaced | swap entity_id, orphan old, sweep when safe |

### Entity Classification

```typescript
// SOURCE STABLE (has track key, survives HMR):
const SOURCE_STABLE = ['operator_fun', 'observable', 'pipe']

// RUNTIME EPHEMERAL (no track key, cascade deleted):
const RUNTIME_EPHEMERAL = ['subscription', 'send', 'arg_call']

// HYBRID (owned by stable, may reference runtime):
// arg.owner_id → operator_fun (stable)
// arg.observable_id → observable (may be runtime-created)
```

### Cascade Delete on Unsubscribe

```typescript
function cascadeDeleteSubscription(subId: string) {
  const store = state$.value.store
  
  // Delete sends for this subscription
  Object.values(store.send)
    .filter(s => s.subscription_id === subId)
    .forEach(s => deleteFromStore('send', s.id))
  
  // Delete arg_calls, check if created observables should also go
  Object.values(store.arg_call)
    .filter(ac => ac.subscription_id === subId)
    .forEach(ac => {
      if (ac.observable_id && !hasActiveSubscriptions(store, ac.observable_id)) {
        deleteFromStore('observable', ac.observable_id)
      }
      deleteFromStore('arg_call', ac.id)
    })
  
  // Recursively delete child subscriptions
  getChildSubscriptions(store, subId)
    .forEach(c => cascadeDeleteSubscription(c.id))
  
  deleteFromStore('subscription', subId)
}
```

### Orphan Sweep (Periodic)

```typescript
function sweepOrphans() {
  const store = state$.value.store
  
  for (const track of Object.values(store.hmr_track)) {
    const stillNeeded: string[] = []
    
    for (const oldEntityId of track.prev_entity_ids) {
      const hasActiveSub = Object.values(store.subscription)
        .filter(s => !s.unsubscribed_at)
        .some(s => subscriptionReachesEntity(store, s.id, track.entity_type, oldEntityId))
      
      if (hasActiveSub) {
        stillNeeded.push(oldEntityId)
      } else {
        cascadeDeleteEntity(track.entity_type, oldEntityId)
      }
    }
    
    if (stillNeeded.length !== track.prev_entity_ids.length) {
      updateStore('hmr_track', track.id, { prev_entity_ids: stillNeeded })
    }
  }
}
```

---

## Open Design Questions

### 1. Stateful Operators (scan, reduce)

Accumulated state lives in closure. On HMR:
- **Preserve state?** Keep running total, just swap accumulator function
- **Reset state?** Start fresh with new seed
- **Configurable?** Let user decide per-operator

Recommendation: Default to preserve. User can manually reset via devtools if needed.

### 2. Timing of Indirection

- **Subscription-time:** Resolve args when subscription created. Simpler but requires resub for new code.
- **Emission-time:** Resolve args on each emission. True hot swap, more overhead.

Recommendation: Emission-time for maximum flexibility. Perf impact likely negligible.

### 3. Dynamic Factory Functions

```typescript
function makeStream(multiplier: number) {
  return of(1, 2, 3).pipe(map(x => x * multiplier))
}
```

Parse-time can't fully track this. Options:
- Require explicit `__$` wrapping inside factory
- Fall back to runtime tracking for dynamic cases
- Accept that factories are opaque to HMR

---

## Implementation Phases

### Phase 1: Manual `__$` Validation

**Goal:** Validate schema design with handwritten instrumentation before building parser.

**Tasks:**
1. Add `hmr_track` to `State` type in `00.types.ts`
2. Implement `__$` runtime in new file `hmr/runtime.ts`
3. Implement `registerTrack`, `processBufferedEvents`
4. Write `manual-track.test.ts` with handwritten `__$` calls
5. Write `deriveStructuralPath` query
6. Write tests: track creation, tree structure, structural hash

**Validation criteria:**
- `hmr_track` records created with correct parent relationships
- Structural path derivation produces expected strings
- Events correctly correlated to track IDs

### Phase 2: Swap Mechanism

**Goal:** Prove HMR swap works with manual simulation.

**Tasks:**
1. Implement `swapTrack` function
2. Implement `teardownTrack` function  
3. Implement indirection layer for operators
4. Write tests: simulate HMR by manually creating new operator_fun, calling swap
5. Verify: subscription survives, new emissions use new code

**Validation criteria:**
- Subscription count unchanged after swap
- Emissions after swap use new function
- Old entity moved to `prev_entity_ids`

### Phase 3: Lifecycle Management

**Goal:** Clean up properly on unsub and after HMR.

**Tasks:**
1. Implement `cascadeDeleteSubscription`
2. Implement `sweepOrphans`
3. Wire cascade delete to unsubscribe events
4. Write tests: verify cleanup after unsub, verify orphan sweep

**Validation criteria:**
- No dangling records after subscription completes
- Orphaned entities cleaned up after referencing subs complete

### Phase 4: AST Pattern Catalog

**Goal:** Document all patterns needing transformation.

**Tasks:**
1. Create `PATTERNS.md` documenting each pattern
2. Create test fixtures: input/output pairs for each pattern
3. Categories:
   - Creation functions: `of`, `from`, `interval`, `timer`, `fromEvent`, etc.
   - Constructors: `Observable`, `Subject`, `BehaviorSubject`, `ReplaySubject`
   - Pipe operators: all pipeable operators
   - Nested observables in args: `switchMap`, `mergeMap`, `concatMap`, etc.

### Phase 5: Vite Plugin

**Goal:** Auto-transform RxJS code with `__$` calls.

**Tasks:**
1. Scaffold plugin structure
2. Implement pattern matching with Babel traverse
3. Implement `__$` injection with source location
4. Unit tests: input code → output code assertions
5. Source map preservation

### Phase 6: Integration Tests (Playwright)

**Goal:** End-to-end validation of HMR in browser.

**Tasks:**
1. Create test harness page
2. Implement HMR simulation (file change → module reload)
3. Write tests:
   - Subscription survives HMR
   - New emissions use new code
   - Structural change triggers teardown
   - DevTools show version info

---

## File Structure

```
src/
├── 00.types.ts              # Add hmr_track to State
├── 01_helpers.ts            # Existing
├── 01.patch-observable.ts   # Existing
├── 03_scan-accumulator.ts   # Wire hmr_track writes
├── 04.operators.ts          # Existing proxy
├── 05_render-tree.ts        # Existing
├── 06_queries.ts            # Add deriveStructuralPath
├── hmr/
│   ├── runtime.ts           # __$, registerTrack, processBufferedEvents
│   ├── swap.ts              # swapTrack, teardownTrack, handleHMR
│   ├── lifecycle.ts         # cascadeDelete, sweepOrphans
│   └── queries.ts           # HMR-specific queries
├── vite-plugin/
│   ├── index.ts             # Plugin entry
│   ├── patterns.ts          # AST pattern matchers
│   └── transform.ts         # Code generation
└── tests/
    ├── manual-track.test.ts # Phase 1 validation
    ├── swap.test.ts         # Phase 2 validation
    ├── lifecycle.test.ts    # Phase 3 validation
    ├── plugin.test.ts       # Phase 5 transform tests
    └── e2e/
        └── hmr.spec.ts      # Playwright tests
```

---

## First Task

Start with Phase 1: Add `hmr_track` to types and implement `__$` runtime.

1. Read `00.types.ts` to understand current State shape
2. Add `hmr_track` entity type to `Improved` and `State`
3. Create `src/hmr/runtime.ts` with `__$` implementation
4. Create `src/hmr/queries.ts` with `deriveStructuralPath`
5. Create `tests/manual-track.test.ts` with handwritten `__$` usage
6. Run tests, iterate until passing




Right. Each operator exercises different arg patterns:

```
Operator        Arg Complexity
────────        ──────────────
map             fn(value) → value
filter          fn(value) → boolean
scan            fn(acc, value) → acc, seed value, STATEFUL
switchMap       fn(value) → Observable, INNER OBS CREATION
repeat          { delay: fn(count) → Observable, count: number }
share           INTERNAL SUBJECT, stateful refcount
BehaviorSubject CONSTRUCTOR ARG (initial value), IS SOURCE
combineLatest   OBSERVABLE REFS as args
```

## Test Matrix by Phase

### Phase 1: `__$` Track Creation

Validate track records created correctly with tree structure.

```typescript
describe('Phase 1: __$ track creation', () => {
  
  // Simple value transform
  it('tracks map with fn arg', () => {
    __$('test:1:pipe', $ =>
      of(1).pipe(
        $('map', map(x => x * 2))
      )
    )
    
    expect(store.hmr_track['test:1:pipe:map']).toMatchObject({
      entity_type: 'operator_fun',
      parent_track_id: 'test:1:pipe'
    })
    expect(getArgsFor(store, track.entity_id)).toMatchObject([
      { path: '$args.0', is_function: true }
    ])
  })

  // Multiple arg types
  it('tracks scan with fn + seed', () => {
    __$('test:2:pipe', $ =>
      of(1, 2, 3).pipe(
        $('scan', scan((acc, x) => acc + x, 100))
      )
    )
    
    const args = getArgsFor(store, track.entity_id)
    expect(args).toMatchObject([
      { path: '$args.0', is_function: true },
      { path: '$args.1', is_function: false, value: 100 }
    ])
  })

  // Nested observable creation
  it('tracks switchMap with inner observable', () => {
    __$('test:3:pipe', $ =>
      of(1).pipe(
        $('switchMap', switchMap(x => 
          __$('test:3:inner', $$ =>
            $$('of', of(x * 2))
          )
        ))
      )
    ).subscribe()
    
    // Outer track
    expect(store.hmr_track['test:3:pipe:switchMap']).toBeDefined()
    // Inner track (created during subscription)
    expect(store.hmr_track['test:3:inner:of']).toBeDefined()
    // arg_call links them
    expect(Object.values(store.arg_call)[0]).toMatchObject({
      observable_id: /* inner observable id */
    })
  })

  // Object arg with nested functions
  it('tracks repeat with delay fn + count', () => {
    __$('test:4:pipe', $ =>
      of(1).pipe(
        $('repeat', repeat({ 
          delay: (count) => __$('test:4:delay', $$ => 
            $$('timer', timer(100))
          ),
          count: 2 
        }))
      )
    )
    
    const args = getArgsFor(store, track.entity_id)
    expect(args).toMatchObject([
      { path: '$args.0.delay', is_function: true },
      { path: '$args.0.count', is_function: false, value: 2 }
    ])
  })

  // Constructor tracking
  it('tracks BehaviorSubject with initial value', () => {
    __$('test:5:bs', $ =>
      $('BehaviorSubject', new BehaviorSubject(42))
    )
    
    expect(store.hmr_track['test:5:bs:BehaviorSubject']).toMatchObject({
      entity_type: 'observable'
    })
    const args = getArgsFor(store, track.entity_id)
    expect(args).toMatchObject([
      { path: '$args.0', value: 42 }
    ])
  })

  // Stateful sharing
  it('tracks share with internal subject', () => {
    __$('test:6:pipe', $ =>
      of(1, 2, 3).pipe(
        $('share', share())
      )
    )
    
    // share creates internal Subject - verify it's linked
    expect(store.hmr_track['test:6:pipe:share']).toBeDefined()
  })

  // Observable refs as args
  it('tracks combineLatest with observable refs', () => {
    const a$ = __$('test:7:a', $ => $('of', of(1)))
    const b$ = __$('test:7:b', $ => $('of', of(2)))
    
    __$('test:7:combine', $ =>
      $('combineLatest', combineLatest([a$, b$]))
    )
    
    const args = getArgsFor(store, track.entity_id)
    expect(args).toMatchObject([
      { path: '$args.0.0', observable_id: /* a$ id */ },
      { path: '$args.0.1', observable_id: /* b$ id */ }
    ])
  })

  // Tree structure
  it('builds correct parent chain', () => {
    __$('test:8:pipe', $ =>
      of(1).pipe(
        $('map', map(x => x * 2)),
        $('filter', filter(x => x > 0)),
        $('switchMap', switchMap(x =>
          __$('test:8:inner', $$ =>
            $$('of', of(x)).pipe(
              $$('delay', delay(100))
            )
          )
        ))
      )
    )
    
    // Verify parent_track_id chain
    expect(store.hmr_track['test:8:pipe:map'].parent_track_id).toBe('test:8:pipe')
    expect(store.hmr_track['test:8:pipe:filter'].parent_track_id).toBe('test:8:pipe')
    expect(store.hmr_track['test:8:inner:delay'].parent_track_id).toBe('test:8:inner')
  })

  // Structural path derivation
  it('derives structural path correctly', () => {
    __$('test:9:pipe', $ =>
      of(1).pipe(
        $('map', map(x => x * 2)),
        $('filter', filter(x => x > 0)),
        $('scan', scan((a, x) => a + x, 0))
      )
    )
    
    expect(deriveStructuralPath(store, 'test:9:pipe:scan'))
      .toBe('0:pipe|0:map|1:filter|2:scan')
  })
})
```

### Phase 2: Swap Mechanism

Validate HMR swap preserves subscriptions.

```typescript
describe('Phase 2: HMR swap', () => {

  it('swap preserves subscription for map', async () => {
    const emissions: number[] = []
    
    const obs$ = __$('test:1:pipe', $ =>
      of(1, 2, 3).pipe(
        $('map', map(x => x * 2))
      )
    )
    
    // Use subject so we control emissions
    const source$ = new Subject<number>()
    const tracked$ = __$('test:2:pipe', $ =>
      source$.pipe(
        $('map', map(x => x * 2))
      )
    )
    
    tracked$.subscribe(v => emissions.push(v))
    source$.next(1)
    expect(emissions).toEqual([2])
    
    // Simulate HMR: create new operator_fun with x * 10
    const newOpFunId = simulateNewOperatorFun('map', x => x * 10)
    swapTrack('test:2:pipe:map', newOpFunId)
    
    // Next emission uses NEW code
    source$.next(2)
    expect(emissions).toEqual([2, 20])  // not [2, 4]
    
    // Subscription count unchanged
    expect(getActiveSubscriptionCount()).toBe(1)
  })

  it('swap preserves accumulated state in scan', async () => {
    const source$ = new Subject<number>()
    const emissions: number[] = []
    
    const tracked$ = __$('test:3:pipe', $ =>
      source$.pipe(
        $('scan', scan((acc, x) => acc + x, 0))
      )
    )
    
    tracked$.subscribe(v => emissions.push(v))
    source$.next(1)  // acc = 1
    source$.next(2)  // acc = 3
    expect(emissions).toEqual([1, 3])
    
    // Simulate HMR: change to multiplication
    const newOpFunId = simulateNewOperatorFun('scan', (acc, x) => acc * x, 0)
    swapTrack('test:3:pipe:scan', newOpFunId)
    
    // State preserved! acc is still 3, now we multiply
    source$.next(4)
    expect(emissions).toEqual([1, 3, 12])  // 3 * 4 = 12
  })

  it('swap works for switchMap inner factory', async () => {
    const source$ = new Subject<number>()
    const emissions: string[] = []
    
    const tracked$ = __$('test:4:pipe', $ =>
      source$.pipe(
        $('switchMap', switchMap(x => 
          __$('test:4:inner', $$ =>
            $$('of', of(`v${x}`))
          )
        ))
      )
    )
    
    tracked$.subscribe(v => emissions.push(v))
    source$.next(1)
    expect(emissions).toEqual(['v1'])
    
    // Simulate HMR: change inner factory
    const newOpFunId = simulateNewOperatorFun('switchMap', x => of(`NEW${x}`))
    swapTrack('test:4:pipe:switchMap', newOpFunId)
    
    source$.next(2)
    expect(emissions).toEqual(['v1', 'NEW2'])
  })

  it('swap works for repeat delay function', async () => {
    let delayMs = 100
    const source$ = __$('test:5:source', $ => $('of', of(1)))
    
    const tracked$ = __$('test:5:pipe', $ =>
      source$.pipe(
        $('repeat', repeat({
          delay: () => __$('test:5:delay', $$ => 
            $$('timer', timer(delayMs))
          ),
          count: 3
        }))
      )
    )
    
    // After HMR, delay should use new value
    delayMs = 500
    const newOpFunId = simulateNewOperatorFun('repeat', {
      delay: () => timer(delayMs),
      count: 3
    })
    swapTrack('test:5:pipe:repeat', newOpFunId)
    
    // Verify new delay is used on next repeat cycle
  })

  it('structural change triggers teardown', () => {
    const source$ = new Subject<number>()
    
    const tracked$ = __$('test:6:pipe', $ =>
      source$.pipe(
        $('map', map(x => x * 2)),
        $('filter', filter(x => x > 0))
      )
    )
    
    tracked$.subscribe()
    const initialSubCount = getActiveSubscriptionCount()
    
    // Simulate HMR: REMOVE filter (structural change)
    const newStructure = simulateNewPipe([
      { name: 'map', fn: x => x * 2 }
      // filter removed!
    ])
    
    handleHMR('test:6:pipe', newStructure)
    
    // Old subscription torn down, new one created
    expect(store.hmr_track['test:6:pipe'].version).toBe(2)
    // teardown flag or different sub id
  })

  it('share maintains refcount across HMR', () => {
    const source$ = new Subject<number>()
    const emissions1: number[] = []
    const emissions2: number[] = []
    
    const shared$ = __$('test:7:pipe', $ =>
      source$.pipe(
        $('map', map(x => x * 2)),
        $('share', share())
      )
    )
    
    shared$.subscribe(v => emissions1.push(v))
    shared$.subscribe(v => emissions2.push(v))
    
    source$.next(1)
    expect(emissions1).toEqual([2])
    expect(emissions2).toEqual([2])
    
    // HMR swap the map
    swapTrack('test:7:pipe:map', simulateNewOperatorFun('map', x => x * 10))
    
    source$.next(2)
    // Both subscribers get new value
    expect(emissions1).toEqual([2, 20])
    expect(emissions2).toEqual([2, 20])
    // Still only 1 upstream subscription (share working)
  })

  it('BehaviorSubject swap preserves current value', () => {
    const bs$ = __$('test:8:bs', $ =>
      $('BehaviorSubject', new BehaviorSubject(0))
    )
    
    bs$.next(42)
    expect(bs$.value).toBe(42)
    
    // HMR can't really swap BehaviorSubject... 
    // but we track that initial value arg changed
    // This might trigger a warning in devtools
  })
})
```

### Phase 3: Lifecycle Cleanup

Validate cascade delete and orphan sweep.

```typescript
describe('Phase 3: lifecycle cleanup', () => {

  it('cascade deletes sends on unsubscribe', () => {
    const source$ = new Subject<number>()
    
    const tracked$ = __$('test:1:pipe', $ =>
      source$.pipe($('map', map(x => x * 2)))
    )
    
    const sub = tracked$.subscribe()
    source$.next(1)
    source$.next(2)
    
    expect(Object.keys(store.send).length).toBe(2)
    
    sub.unsubscribe()
    
    expect(Object.keys(store.send).length).toBe(0)
  })

  it('cascade deletes child subscriptions', () => {
    const source$ = new Subject<number>()
    
    const tracked$ = __$('test:2:pipe', $ =>
      source$.pipe(
        $('switchMap', switchMap(x => 
          __$('test:2:inner', $$ => $$('of', of(x, x + 1)))
        ))
      )
    )
    
    const sub = tracked$.subscribe()
    source$.next(1)
    
    // Has parent + child subscriptions
    const subCount = Object.keys(store.subscription).length
    expect(subCount).toBeGreaterThan(1)
    
    sub.unsubscribe()
    
    // All gone
    expect(Object.keys(store.subscription).length).toBe(0)
  })

  it('cascade deletes arg_calls and runtime observables', () => {
    const source$ = new Subject<number>()
    
    const tracked$ = __$('test:3:pipe', $ =>
      source$.pipe(
        $('switchMap', switchMap(x => 
          __$('test:3:inner', $$ => $$('of', of(x)))
        ))
      )
    )
    
    const sub = tracked$.subscribe()
    source$.next(1)
    
    expect(Object.keys(store.arg_call).length).toBeGreaterThan(0)
    expect(Object.keys(store.observable).length).toBeGreaterThan(1)  // source + inner
    
    sub.unsubscribe()
    
    expect(Object.keys(store.arg_call).length).toBe(0)
    // Inner observable deleted, source remains (it's tracked)
  })

  it('orphan sweep cleans up after last subscriber', async () => {
    const source$ = new Subject<number>()
    
    const tracked$ = __$('test:4:pipe', $ =>
      source$.pipe($('map', map(x => x * 2)))
    )
    
    const sub = tracked$.subscribe()
    const originalOpFunId = store.hmr_track['test:4:pipe:map'].entity_id
    
    // HMR swap
    swapTrack('test:4:pipe:map', simulateNewOperatorFun('map', x => x * 10))
    
    // Old entity in orphan list
    expect(store.hmr_track['test:4:pipe:map'].prev_entity_ids).toContain(originalOpFunId)
    // Old operator_fun still exists (subscription using it)
    expect(store.operator_fun[originalOpFunId]).toBeDefined()
    
    sub.unsubscribe()
    sweepOrphans()
    
    // Now cleaned up
    expect(store.hmr_track['test:4:pipe:map'].prev_entity_ids).toEqual([])
    expect(store.operator_fun[originalOpFunId]).toBeUndefined()
  })

  it('orphan sweep preserves entities with active subs', () => {
    const source$ = new Subject<number>()
    
    const shared$ = __$('test:5:pipe', $ =>
      source$.pipe(
        $('map', map(x => x * 2)),
        $('share', share())
      )
    )
    
    const sub1 = shared$.subscribe()
    const sub2 = shared$.subscribe()
    
    const originalOpFunId = store.hmr_track['test:5:pipe:map'].entity_id
    swapTrack('test:5:pipe:map', simulateNewOperatorFun('map', x => x * 10))
    
    sub1.unsubscribe()
    sweepOrphans()
    
    // sub2 still active, orphan preserved
    expect(store.operator_fun[originalOpFunId]).toBeDefined()
    
    sub2.unsubscribe()
    sweepOrphans()
    
    // Now cleaned
    expect(store.operator_fun[originalOpFunId]).toBeUndefined()
  })

  it('repeat cleanup handles multiple inner subscriptions', async () => {
    const tracked$ = __$('test:6:pipe', $ =>
      $('of', of(1)).pipe(
        $('repeat', repeat({
          delay: () => __$('test:6:delay', $$ => $$('timer', timer(10))),
          count: 3
        }))
      )
    )
    
    const emissions: number[] = []
    const sub = tracked$.subscribe(v => emissions.push(v))
    
    await wait(50)  // let repeats happen
    
    // Multiple arg_calls for delay function
    expect(Object.keys(store.arg_call).length).toBe(2)  // called twice (count-1)
    
    sub.unsubscribe()
    
    expect(Object.keys(store.arg_call).length).toBe(0)
  })
})
```

### Phase 4-6: Integration Patterns

```typescript
describe('Integration: complex scenarios', () => {

  it('nested switchMap with shared inner', async () => {
    const source$ = new Subject<number>()
    
    const inner$ = __$('test:inner', $ =>
      $('of', of('shared')).pipe(
        $('share', share())
      )
    )
    
    const outer$ = __$('test:outer', $ =>
      source$.pipe(
        $('switchMap', switchMap(x =>
          inner$.pipe(
            $('map', map(s => `${x}:${s}`))
          )
        ))
      )
    )
    
    // Test HMR on inner vs outer
  })

  it('combineLatest with HMR on one branch', () => {
    const a$ = new Subject<number>()
    const b$ = new Subject<number>()
    
    const tracked$ = __$('test:combine', $ =>
      $('combineLatest', combineLatest([
        a$.pipe($('mapA', map(x => x * 2))),
        b$.pipe($('mapB', map(x => x + 10)))
      ]))
    )
    
    // HMR swap mapA, verify mapB unaffected
  })

  it('BehaviorSubject as source with downstream operators', () => {
    const bs$ = __$('test:bs', $ =>
      $('BehaviorSubject', new BehaviorSubject(0))
    )
    
    const derived$ = __$('test:derived', $ =>
      bs$.pipe(
        $('map', map(x => x * 2)),
        $('distinctUntilChanged', distinctUntilChanged())
      )
    )
    
    // HMR swap map, verify BehaviorSubject value preserved
  })

  it('error recovery with retry + HMR', () => {
    let shouldFail = true
    
    const tracked$ = __$('test:retry', $ =>
      $('defer', defer(() => {
        if (shouldFail) {
          shouldFail = false
          return throwError(() => new Error('fail'))
        }
        return of('success')
      })).pipe(
        $('retry', retry(2))
      )
    )
    
    // HMR during retry cycle
  })

  it('multicasted observable with late subscriber post-HMR', () => {
    const source$ = new Subject<number>()
    
    const shared$ = __$('test:share', $ =>
      source$.pipe(
        $('map', map(x => x * 2)),
        $('shareReplay', shareReplay(1))
      )
    )
    
    shared$.subscribe()  // first subscriber
    source$.next(1)
    
    // HMR
    swapTrack('test:share:map', simulateNewOperatorFun('map', x => x * 10))
    
    // Late subscriber - gets replayed OLD value, then NEW on next emission
    const late: number[] = []
    shared$.subscribe(v => late.push(v))
    
    expect(late).toEqual([2])  // replayed old
    
    source$.next(2)
    expect(late).toEqual([2, 20])  // new code
  })
})
```

## Summary: Test Progression

| Phase | Key Operators | What We're Validating |
|-------|--------------|----------------------|
| 1 | map, scan, switchMap, repeat, BehaviorSubject, combineLatest, share | Track creation, tree structure, arg capture |
| 2 | Same + Subject sources | Swap preserves subs, state, uses new code |
| 3 | Same + unsubscribe | Cascade delete, orphan sweep |
| 4-6 | Combinations | Real-world patterns, edge cases |

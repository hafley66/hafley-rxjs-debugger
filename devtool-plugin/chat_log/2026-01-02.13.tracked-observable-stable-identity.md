# Session: trackedObservable as Stable Identity

## Context
Continuing work on HMR support for RxJS debugger. Previous session implemented module lifecycle with orphan cleanup. This session redesigns how trackedObservable handles subscriptions.

## Problem Statement

trackedObservable was invisible (created with `__withNoTrack`). When users subscribe, the subscription pointed to ephemeral inner observable IDs. This caused:
1. Subscription.observable_id changes on HMR (unstable)
2. Internal forwarding subscription emits send events (noise)
3. Synthetic subscription context needed for defer factory scoping (hacky)

## New Architecture

**trackedObservable IS the tracked entity** - the stable identity users interact with.

### Key Principles

1. **Track key = observable_id** - Register trackedObservable in `store.observable` with track key as ID (e.g., `"fetch$:abc123"`)
2. **User subscriptions are stable** - `subscription.observable_id = "fetch$:abc"` (doesn't change on HMR)
3. **Internal forwarding is invisible** - trackedObservable → inner subscription uses `__withNoTrack`
4. **Send events from stable ref** - When inner emits, send event references wrapper's ID
5. **HMR swap is transparent** - Unsubscribe old inner, subscribe new inner, user subscriptions unaffected

### Store Structure

```
factory-call-return: store.observable["0"] = { name: "of(1)", obs_ref: inner }
track-call-return:   store.observable["fetch$:abc"] = { name: "of(1)", obs_ref: wrapper }
                     hmr_track["fetch$:abc"].entity_id = "0"
```

- Inner still tracked (needed for `obs_ref` lookup via `entity_id`)
- Outer uses track key as ID
- Outer's name = inner's name (1:1 since hash matches structure)

### HMR Behavior

**Same structure (fn-only swap):**
- Same track key, same entries
- Just swap which inner the wrapper connects to

**Different structure:**
- New track key "fetch$:def" (different hash)
- Old track "fetch$:abc" orphaned → cleanup
- Fresh entries

### Defer Factory Flow

```
1. defer's factory is decorated as an arg (arg.is_function = true)
2. User subscribes to trackedObservable("fetch$")
   → subscription created: { id: "42", observable_id: "fetch$" }
   → trackedObservable subscribes to defer's inner (triggers factory via arg-call)
   → factory runs with subscription "42" in context
   → inner observable created, scoped: "$ref[fetch$]:subscription[42]:inner"

3. HMR changes structure (new hash for factory content):
   → trackedObservable detects entity_id change
   → unsubscribes from old defer inner
   → subscribes to new defer inner (triggers new factory via arg-call)
   → new factory runs with SAME subscription "42" in context
   → new inner observable created with same scope key
   → from tracking POV, it's structurally the "same" subscription
```

### Infinite Loop Prevention

The `__withNoTrack` was there to prevent loops from:
1. trackedObservable subscribing to `state$$` (the watcher)
2. Internal subscription to the inner observable

**Solution:** Keep `__withNoTrack` specifically for internal plumbing:

```ts
// Wrapper is tracked (in store.observable)
// But internal plumbing uses __withNoTrack

const connectToSource = (entityId: string) => {
  innerSub = __withNoTrack(() =>  // prevents send loops
    sourceObs.subscribe({
      next: v => subscriber.next(v),  // triggers send from wrapper's ID
      ...
    })
  )
}

const watchSub = __withNoTrack(() =>  // prevents infinite watcher triggers
  state$$.subscribe(...)
)
```

Send events fire from the wrapper (correct ID), but the internal mechanics don't emit events.

## Implementation

### Event Design: Option A (chosen)

Extend `track-call-return` handling in accumulator:

```ts
case "track-call-return": {
  const entity = state.stack.hmr_track.pop()
  // ... existing logic ...

  // Register wrapper in store.observable (no new events, just state mutation)
  const wrapper = entity.stable_ref?.deref()
  if (wrapper) {
    state.store.observable[entity.id] = {
      id: entity.id,
      created_at: now(),
      name: state.store.observable[entity.entity_id]?.name ?? `tracked(${entity.id})`,
      obs_ref: entity.stable_ref,
    }
    observableIdMap.set(wrapper, entity.id)
  }
}
```

No new event type needed - just extended accumulator logic.

### Files to Modify

1. `src/tracking/v2/hmr/2_tracked-observable.ts` - keep __withNoTrack for internals
2. `src/tracking/v2/hmr/3_tracked-subject.ts` - same pattern
3. `src/tracking/v2/03_scan-accumulator.ts` - extend track-call-return handling
4. Test files - update snapshots

## Resolved Decisions

1. **trackedSubject follows same pattern** - registered with track key as observable_id
2. **Both inner and outer tracked** - inner for obs_ref lookup, outer for user-facing subscriptions
3. **Reuse existing event** - extend track-call-return, no new event type
4. **Keep __withNoTrack for internals** - prevents infinite loops while allowing wrapper to be tracked

## Changes Made This Session

1. Added Observable patching to test setup (`0_test-utils.ts`)
2. Added PATCHED_UNSUB marker to prevent double-patching (`01.patch-observable.ts`)
3. Added synthetic subscription push for defer scoping (`2_tracked-observable.ts`) - TO BE REPLACED
4. Added subscription stack check to __$ (`0_runtime.ts`)
5. Added suppressSend$ infrastructure (`00.types.ts`, `01.patch-observable.ts`) - MAY NOT BE NEEDED

## Next Steps

1. Implement stable identity architecture (accumulator changes)
2. Remove synthetic subscription hack
3. Update and verify tests
4. Clean up unused code (suppressSend$ if not needed)

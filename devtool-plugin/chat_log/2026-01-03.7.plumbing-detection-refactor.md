# Session: Internal Plumbing Detection Refactor

## Goal
Detect wrapper→inner subscriptions relationally in accumulator instead of using `__withNoTrack` everywhere. Clean up `stable_ref` redundancy.

## Current State
- **Branch**: `feature/vite-instrumentation-v2`
- **Tests**: 129 passing, 1 failing (`defer factory runs with subscription context`)
- **Snapshots**: Updated

## Problem/Context
When trackedObservable subscribes to its inner observable, we need to skip tracking that internal subscription. Originally used `__withNoTrack()` everywhere. Goal is to detect this relationally:

```
hmr_track[key] {
  stable_observable_id: "3"  ← wrapper
  mutable_observable_id: "2" ← inner
}

subscription from "3" → "2" = internal plumbing (skip)
subscription from user → "3" = external (track)
```

## Solution/Approach

### 1. Internal Plumbing Detection (DONE)
Added detection in `subscribe-call` handler in `03_scan-accumulator.ts`:
```typescript
const parentSub = state.stack.subscription.at(-1)
if (parentSub) {
  const isInternalPlumbing = Object.values(state.store.hmr_track).some(
    t => t.stable_observable_id === parentSub.observable_id
      && t.mutable_observable_id === event.observable_id,
  )
  if (isInternalPlumbing) break // Skip tracking wrapper→inner subscription
}
```

### 2. Fixed stable_observable_id Timing (DONE)
- TRACKED_MARKER can't work because constructor-call-return fires BEFORE marker is set
- Runtime now explicitly sets `stable_observable_id = (stable as any).__id__`
- Also captures `mutableIdBeforeWrapper` and restores it (wrapper's constructor overwrites it)

### 3. Removed stable_ref Redundancy (DONE)
- Removed `stable_ref` from hmr_track type
- Use `store.observable[stable_observable_id].obs_ref` instead (single source of truth)

### 4. DEBUG_CONFIG Flag (DONE)
Added `DEBUG_CONFIG.skipNoTrack` in `2_tracked-observable.ts` to toggle between:
- `false` (default): Uses `__withNoTrack` for inner subscription
- `true`: Relies on accumulator detection

## Tasks
- [ ] Fix failing test: `defer factory runs with subscription context` (values not flowing)
- [ ] Investigate why defer + nested __$ isn't emitting values
- [ ] Consider if trackedSubject needs similar treatment (currently keeps `__withNoTrack`)

## Files Modified
- `src/tracking/v2/00.types.ts` - Removed `stable_ref` from hmr_track type
- `src/tracking/v2/03_scan-accumulator.ts` - Added plumbing detection, updated stable_ref usages
- `src/tracking/v2/hmr/0_runtime.ts` - Set stable_observable_id explicitly, restore mutable_observable_id
- `src/tracking/v2/hmr/2_tracked-observable.ts` - Added DEBUG_CONFIG flag
- `src/tracking/v2/hmr/6_plumbing-detection.test.ts` - Debug test comparing with/without __withNoTrack
- `src/tracking/v2/hmr/0_runtime.test.ts` - Fixed entity_id → mutable_observable_id references

## Key Insights
1. **TRACKED_MARKER timing issue**: Constructor-call-return fires before marker can be set on instance
2. **Wrapper overwrites mutable_observable_id**: Must capture before creating wrapper, restore after
3. **obs_ref is single source of truth**: No need for separate stable_ref WeakRef
4. **Detection only works when parent subscription exists**: trackedSubject's subscribeToInner happens at creation time (no parent), so must keep __withNoTrack there

## Debug Test Snapshot (working)
```
"mutable_observable_id": "1",  // raw Subject
"stable_observable_id": "2",   // wrapper
"areDistinct": true,
"values": [42],  // values flowing!
```

## Open Questions
- Why does `defer factory` test fail? Values not flowing through nested __$ inside defer callback
- Should we eventually remove __withNoTrack entirely and rely on detection?
- Does the detection need to handle more edge cases?
